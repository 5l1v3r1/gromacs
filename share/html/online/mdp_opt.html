<html>
 <title>mdp options</title>
<body>

<h1>mdp options</h1>
<a NAME="TOP"></a>
<h3>
<img SRC="charts_cont.gif" > Table of Contents:</h3>

<ul>
<li>
<b><a href="#general">General remarks</a></b></li>

<li>
<b><a href="#pp">preprocessing</a></b> (title, warnings, cpp, include,
define)</li>

<li>
<b><a href="#run">run control</a></b> (integrator, tinit, dt, nsteps, nstcomm)</li>

<li>
<b><a href="#ld">langevin dynamics</a></b> (ld_temp, ld_fric, ld_seed)</li>

<li>
<b><a href="#em">energy minimization</a></b> (emtol, emstep, nstcgsteep)</li>

<li>
<b><a href="#out">output control</a></b> (nstxout, nstvout, nstfout, nstlog,
nstenergy, nstxtcout, xtc_precision, xtc_grps, energygrps)</li>

<li>
<b><a href="#nl">neighborsearching</a></b> (nstlist, ns_type, deltagrid,
box, rlist)</li>

<li>
<b><a href="#el">electrostatics and VdW</a></b> (coulombtype, rcoulomb_switch,
rcoulomb, vdwtype, rvdw_switch, rvdw, epsilon_r, bDispCorr, niter, gauss_width,
fourier_nx, fourier_ny, fourier_nz,pme_order,ewald_rtol,optimize_fft)</li>

<li>
<b><a href="#tc">Temperature coupling</a></b> (tcoupl, ntcmemory, tc_grps,
tau_t, ref_t)</li>

<li>
<b><a href="#pc">Pressure coupling</a></b> (pcoupl, npcmemory, tau_p, compressibility,
ref_p)</li>

<li>
<b><a href="#sa">simulated annealing</a></b> (annealing, zero_temp_time)</li>

<li>
<b><a href="#vel">velocity generation</a></b> (gen_vel, gen_temp, gen_seed)</li>

<li>
<b><a href="#sol">solvent optimization</a></b> (solvent_optimization, nsatoms)</li>

<li>
<b><a href="#bond">bonds</a></b> (constraints, constraint_algorithm, unconstrained_start,
shake_tol, lincs_order, lincs_warnangle, nstlincsout, morse)</li>

<li>
<b><a href="#nmr">NMR refinement</a></b> (disre, disre_weighting, disre_mixed,
disre_fc, disre_tau, nstdisreout)</li>

<li>
<b><a href="#free">Free energy</a></b> (free_energy, init_lambda, delta_lambda)</li>

<li>
<b><a href="#neq">Non-equilibrium MD</a></b> (acc_grps, accelerate, freezegrps,
freezedim )</li>

<li>
<b><a href="#ef">Electric fields</a></b> (E_x, E_xt, E_y, E_yt, E_z, E_zt
)</li>

<li>
<b><a href="#user">User defined thingies</a></b> (user1_grps, user2_grps,
user3_grps, userint1, userint2, userint3, userint4, userreal1, userreal2,
userreal3, userreal4)</li>

<li>
<a href="#idx"><img SRC="charts_idx.gif"  align=ABSCENTER></a><b><a href="#idx">
Index</a></b></li>
</ul>

<hr><a NAME="general"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#top"><img SRC="charts_up.gif" ></a><a href="#pp"><img SRC="charts_down.gif" ></a>
General:</h3>
Default values are given in parentheses. The first option is always the
default option. Units are given in square brackets The difference between
a dash and an underscore is ignored.
<p>A <a href="mdp.html">sample <tt>.mdp</tt> file</a> is available. This
should be appropriate to start a normal simulation. Edit it to suit your
specific needs and desires.
<br>
<hr><a NAME="pp"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#general"><img SRC="charts_up.gif" ></a><a href="#run"><img SRC="charts_down.gif" ></a>
Preprocessing:</h3>

<dl>
<h4>
title:</h4>

<dd>
this is reduntant, so you can type anything you want</dd>

<h4>
cpp: (/lib/cpp)</h4>

<dd>
your preprocessor</dd>

<h4>
include:</h4>

<dd>
directories to include in your topology. format:</dd>

<pre>-I/home/john/my_lib -I../more_lib</pre>

<h4>
define: ()</h4>

<dd>
defines to pass to the preprocessor, default is no defines. You can use
any defines to control options in your customized topology files. Options
that are already available by default are:</dd>

<dl compact>
<dt>
<b>-DFLEX_SPC</b></dt>

<dd>
Will tell grompp to include FLEX_SPC in stead of SPC into your topology,
this is necessary to make the energy minimizing integrators (<b><a href="#run">steep</a></b>
and <b><a href="#run">cg</a></b>) work.</dd>

<dt>
<b>-DPOSRE</b></dt>

<dd>
Will tell grompp to include posre.itp into your topology, used for position
restraints.</dd>
</dl>
</dl>
<a NAME="run"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#pp"><img SRC="charts_up.gif" ></a><a href="#ld"><img SRC="charts_down.gif" ></a>
Run control:</h3>

<dl>
<h4>
integrator:</h4>

<dl compact>
<dt>
<b>md</b></dt>

<dd>
A leap-frog algorithm for integrating Newtons equations.</dd>

<dt>
<b>steep</b></dt>

<dd>
A steepest descent algorithm for energy minimization. The maximum stepsize
is <b><a href="#em">emstep</a></b> [nm], the tolerance is <b><a href="#em">emtol</a></b>
[<sup>kJ</sup>/<sub>mol nm</sub>].</dd>

<dt>
<b>cg</b></dt>

<dd>
A conjugate gradients algorithm for energy minimization, the tolerance
is <b>emtol</b> [<sup>kJ</sup>/<sub>mol nm</sub>]. CG is more efficient
when a steepest descent step is done every once in a while, this is determined
by <b><a href="#em">nstcgsteep</a></b>.</dd>

<dt>
<b>ld</b></dt>

<dd>
An Euler integrator for position Langevin dynamics, the velocity is the
force divided by a friction coefficient (<b><a href="#ld">ld_fric</a></b>
[amu/ps]) plus random thermal noise (<b><a href="#ld">ld_temp</a></b> [K]).
The random generator is initialized with <b><a href="#ld">ld_seed</a></b></dd>
</dl>

<h4>
tinit: (0) [ps]</h4>

<dd>
starting time for your run (only makes sense for integrators <b>md</b>
and <b>ld</b>)</dd>

<h4>
dt: (0.001) [ps]</h4>

<dd>
time step for integration (only makes sense for integrators <b>md</b> and
<b>ld</b>)</dd>

<h4>
nsteps: (1)</h4>

<dd>
maximum number of steps to integrate</dd>

<h4>
nstcomm: (1) [steps]</h4>

<dd>
if positive: frequency for center of mass motion removal</dd>

<dd>
if negative: frequency for center of mass motion and rotational motion
removal (should only be used for vacuum simulations)</dd>
</dl>
<a NAME="ld"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#run"><img SRC="charts_up.gif" ></a><a href="#em"><img SRC="charts_down.gif" ></a>
Langevin dynamics</h3>

<dl>
<h4>
ld_temp: (300) [K]</h4>

<dd>
temperature in ld run (controls thermal noise level)</dd>

<h4>
ld_fric: (0) [amu/ps]</h4>

<dd>
ld friction coefficient</dd>

<h4>
ld_seed: (1993) [integer]</h4>

<dd>
used to initialize random generator for thermal noise</dd>

<dd>
when <b>ld_seed</b> is set to -1, the seed is calculated as
<tt>(time()
+ getpid()) % 65536</tt></dd>
</dl>
<a NAME="em"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#ld"><img SRC="charts_up.gif" ></a><a href="#out"><img SRC="charts_down.gif" ></a>
Energy minimization</h3>

<dl>
<h4>
emtol: (1.0) [<sup>kJ</sup>/<sub>mol nm</sub>]</h4>

<dd>
the minimization is converged when the RMS (<b>steep</b>) or maximum (<b>cg</b>)
force is smaller than this value</dd>

<h4>
emstep: (0.1) [?]</h4>

<dd>
initial step-size, the dimension is nm^2 mol/kJ for <b>steep</b> and nm
for <b>cg</b></dd>

<h4>
nstcgsteep: (1000) [steps]</h4>

<dd>
frequency of performing 1 steepest descents step while doing conjugate
gradients energy minimization.</dd>
</dl>
<a NAME="out"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#em"><img SRC="charts_up.gif" ></a><a href="#nl"><img SRC="charts_down.gif" ></a>
Output control</h3>

<dl>
<h4>
nstxout: (100) [steps]</h4>

<dd>
frequency to write coordinates to output trajectory</dd>

<h4>
nstvout: (100) [steps]</h4>

<dd>
frequency to write velocities to output trajectory</dd>

<h4>
nstfout: (0) [steps]</h4>

<dd>
frequency to write forces to output trajectory</dd>

<h4>
nstlog: (100) [steps]</h4>

<h4>
nstenergy: (100) [steps]</h4>

<dd>
frequency to write energies to log file and energy file</dd>

<h4>
nstxtcout: (0) [steps]</h4>

<dd>
frequency to write coordinates to xtc trajectory</dd>

<h4>
xtc_precision: (1000) [real]</h4>

<dd>
precision to write to xtc trajectory</dd>

<h4>
xtc_grps:</h4>

<dd>
group(s) to write to xtc trajectory, default the whole system is written
(if <b>nstxtcout</b> is larger than zero)</dd>

<h4>
energygrps:</h4>

<dd>
group(s) to write to energy file</dd>
</dl>
<a NAME="nl"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#out"><img SRC="charts_up.gif" ></a><a href="#el"><img SRC="charts_down.gif" ></a>
Neighborsearching</h3>

<dl>
<h4>
nstlist: (10) [steps]</h4>

<dd>
frequency to update neighborlist</dd>

<h4>
ns_type:</h4>

<dl compact>
<dt>
<b>grid</b></dt>

<dd>
Make a grid in the box and only check atoms in neighboring grid cells when
constructing a new neighborlist every <b>nstlist</b> steps. The number
of grid cells per Coulomb cut-off length is set with <b>deltagrid</b>,
this number should be 2 for optimal performance. In large systems grid
search is much faster than simple search.</dd>

<dt>
<b>simple</b></dt>

<dd>
Check every atom in the box when constructing a new neighborlist every
<b>nstlist</b> steps.</dd>
</dl>

<h4>
deltagrid: (2)</h4>

<dd>
number of grid cells per Coulomb cut-off length</dd>

<h4>
box:</h4>

<dl compact>
<dt>
<b>rectangular</b></dt>

<dd>
Selects a rectangular box shape.</dd>

<dt>
<b>triclinic</b></dt>

<dd>
(NOTE: not fully implemented) Selects a triclinic box shape.</dd>

<dt>
<b>none</b></dt>

<dd>
Selects no box, for use in vacuum simulations.</dd>
</dl>

<h4>
rlist: (1) [nm]</h4>

<dd>
cut-off distance for making the neighbor list</dd>
</dl>
<a NAME="el"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#nl"><img SRC="charts_up.gif" ></a><a href="#tc"><img SRC="charts_down.gif" ></a>
Electrostatics and VdW</h3>

<dl>
<h4>
coulombtype:</h4>

<dl compact>
<dt>
<b>Cut-off</b></dt>

<dd>
Twin range cut-off's with neighborlist cut-off <b>rlist</b> and Coulomb
cut-off <b>rcoulomb</b>, where <b>rlist</b> <tt>&lt;=</tt> <b>rvdw</b>
<tt>&lt;=</tt> <b>rcoulomb</b>. The dielectric constant is set with <b>epsilon_r</b>.</dd>

<dt>
<b>PPPM</b></dt>

<dd>
</dd>

<dd>
Particle-Particle Particle-Mesh algorithm for long range electrostatic
interactions. Use for example <b>rlist</b><tt>=1.0</tt>, <b>rcoulomb_switch</b><tt>=0.0</tt>,
<b>rcoulomb</b><tt>=0.85</tt>,
<b>rvdw_switch</b><tt>=1.0</tt> and <b>rvdw</b><tt>=1.0</tt>, The grid
dimensions are controlled by <b>fourier_nx, fourier_ny, fourier_nz</b>.
Reasonable grid spacing for PPPM is 0.05-0.1 nm. See <tt>Shift</tt> for
the details of the particle-particle potential. NOTE:&nbsp;Pressure scaling
is not possible with PPPM.</dd>
</dl>

<dd>
<b>Ewald</b></dd>

<dl compact>
<dd>
Classical Ewald sum electrostatics. Use e.g. <b>rlist</b>=0.9, <b>rvdw</b>=0.9,
<b>rcoulomb</b>=0.9. The highest magnitude of wavevectors used in reciprocal
space is controlled by <b>fourier_nx, fourier_ny, fourier_nz. </b>Reasonable
values are about 5. The relative accuracy of direct/reciprocal space is
controlled by <b>ewald_rtol.</b> NOTE: Ewald scales as O(N*N) and is thus
extremely slow for large systems. It is included mainly for reference -
in most cases PME&nbsp;will perform much better.</dd>
</dl>

<dd>
<b>PME</b></dd>

<dl compact>
<dd>
Fast Particle-Mesh Ewald electrostatics. Direct space is similar to the
Ewald sum, while the reciprocal part is performed with FFTs. Grid dimensions
are controlled as for PPPM, and the interpolation order with <b>pme_order.</b>
With a grid spacing of 0.1nm and (cubic interpolation)&nbsp;the electrostatic
forces have an accuracy of 2-3e-4. Since the error from the vdw-cutoff
is larger than this you might try 0.15 nm. When running in parallel the
interpolation parallelizes better than the FFT, so try decreasing grid
dimensions while increasing interpolation.</dd>

<dt>
<b>Reaction-Field</b></dt>

<dd>
Reaction field with Coulomb cut-off <b>rcoulomb</b>, where <b>rcoulomb</b>
<tt>>=</tt> <b>rvdw</b> <tt>>=</tt> <b>rlist</b>. The dielectric constant
beyond the cut-off is <b>epsilon_r</b>. The dielectric constant can be
set to infinity by setting <b>epsilon_r</b>=0.</dd>

<dt>
<b>Generalized-Reaction-Field</b></dt>

<dd>
Generalized reaction field with Coulomb cut-off <b>rcoulomb</b>, where
<b>rcoulomb</b> <tt>>=</tt> <b>rvdw</b> <tt>>=</tt> <b>rlist</b>. The dielectric
constant beyond the cut-off is <b>epsilon_r</b>. The ionic strength is
computed from the number of charged (i.e. with non zero charge) charge
groups. The temperature for the GRF potential is set with <b><a href="#tc">ref_t</a></b>
[K].</dd>

<dt>
<b>Shift</b></dt>

<dd>
The Coulomb potential is decreased over the whole range and the forces
decay smoothly to zero between <b>rcoulomb_switch</b> and <b>rcoulomb</b>.
The neighborsearch cut-off <b>rlist</b> should be 0.1 to 0.3 nm larger
than
<b>rcoulomb</b> to accommodate for the size of charge groups and diffusion
between neighborlist updates.</dd>

<dt>
<b>User</b></dt>

<dd>
Specify <b>rshort</b> and <b>rlong</b> to the same value, <tt>mdrun</tt>
will now expect to find a file <tt>ctab.xvg</tt> with user-defined functions.
This files should contain 5 columns: the <tt>x</tt> value, and the function
value with its 1<sup>st</sup> to 3<sup>rd</sup> derivative. The <tt>x</tt>
should run from 0 [nm] to
<b>rlist</b><tt>+0.5</tt> [nm], with a spacing
of <tt>0.002</tt> [nm] when you run in single precision, or <tt>0.0005</tt>
[nm] when you run in double precision. The function value at <tt>x=0</tt>
is not important.</dd>
</dl>
<a NAME="el2"></a>
<h4>
rcoulomb_switch: (0) [nm]</h4>

<dd>
where to start switching the Coulomb potential</dd>

<h4>
rcoulomb: (1) [nm]</h4>

<dd>
distance for the Coulomb cut-off</dd>

<h4>
epsilon_r: (1)</h4>

<dd>
dielectric constant</dd>

<h4>
vdwtype:</h4>

<dl compact>
<dt>
<b>Cut-off</b></dt>

<dd>
Twin range cut-off's with neighborlist cut-off <b>rlist</b> and VdW cut-off
<b>rvdw</b>, where <b>rvdw</b> <tt>>=</tt> <b>rlist</b>.</dd>

<dt>
<b>Shift</b></dt>

<dd>
The LJ (not Buckingham) potential is decreased over the whole range and
the forces decay smoothly to zero between <b>rvdw_switch</b> and <b>rvdw</b>.
The neighborsearch cut-off <b>rlist</b> should be 0.1 to 0.3 nm larger
than
<b>rvdw</b> to accommodate for the size of charge groups and diffusion
between neighborlist updates.</dd>

<dt>
<b>User</b></dt>

<dd>
<tt>mdrun</tt> will now expect to find two files with user-defined functions:
<tt>rtab.xvg</tt> for Repulsion, <tt>dtab.xvg</tt> for Dispersion. These
files should contain 5 columns: the <tt>x</tt> value, and the function
value with its 1<sup>st</sup> to 3<sup>rd</sup> derivative. The <tt>x</tt>
should run from 0 [nm] to
<b>rvdw</b><tt>+0.5</tt> [nm], with a spacing
of <tt>0.002</tt> [nm] when you run in single precision, or <tt>0.0005</tt>
[nm] when you run in double precision. The function value at <tt>x=0</tt>
is not important. When you want to use LJ correction, make sure that <b>rvdw</b>
corresponds to the cut-off in the user-defined function.</dd>
</dl>

<h4>
rvdw_switch: (0) [nm]</h4>

<dd>
where to start switching the LJ potential</dd>

<h4>
rvdw: (1) [nm]</h4>

<dd>
distance for the LJ or Buckingham cut-off</dd>

<h4>
bDispCorr:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
don't apply any correction</dd>

<dt>
<b>yes</b></dt>

<dd>
apply long range dispersion corrections for Energy and Pressure</dd>
</dl>

<h4>
gauss_width (0.1) ;</b></h4>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>for future
use
<h4>
fourier_nx </b>(10)<b>; fourier_ny </b>(10)<b> ; fourier_nz: </b>(10)</h4>

<dd>
Highest magnitude of wavevectors in reciprocal space when using Ewald.</dd>

<dd>
Grid size when using PPPM&nbsp;or PME. The best choice is powers of 2,
or at least products of 2,3,5. Avoid large primes.</dd>

<h4>
pme_order (4)</h4>

<dd>
Interpolation order for PME. 4 equals cubic interpolation. You might try
6/8/10 when running in parallel and simultaneously decrease grid dimension.</dd>

<h4>
ewald_rtol (1e-5)</h4>

<dd>
The relative strength of the Ewald-shifted direct potential at the cutoff
is given by <b>ewald_rtol.</b> Decreasing this will give a more accurate
direct sum, but then you need more wavevectors for the reciprocal sum.</dd>

<h4>
optimize_fft (no)</h4>

<dd>
Calculate the optimal FFT plan for the grid at start. This saves a
few percent for long simulations, but takes a couple of minutes
at start.</dd>
</dl>
<a NAME="tc"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#el"><img SRC="charts_up.gif" ></a><a href="#pc"><img SRC="charts_down.gif" ></a>
Temperature coupling</h3>

<dl>
<h4>
tcoupl:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
No temperature coupling.</dd>

<dt>
<b>yes</b></dt>

<dd>
Temperature coupling with a Berendsen-thermostat to a bath with temperature
<b>ref_t</b> [K], with time constant <b>tau_t</b> [ps]. Several groups
can be coupled seperately, these are specified in the
<b>tc_grps</b> field
seperated by spaces.</dd>
</dl>

<h4>
ntcmemory: (1) [steps]</h4>

<dd>
memory for running average to couple to bath</dd>

<h4>
tc_grps:</h4>

<dd>
groups to couple separately to temperature bath</dd>

<h4>
tau_t: [ps]</h4>

<dd>
time constant for coupling (one for each group in tc_grps)</dd>

<h4>
ref_t: [K]</h4>

<dd>
reference temperature for coupling (one for each group in tc_grps)</dd>
</dl>
<a NAME="pc"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#tc"><img SRC="charts_up.gif" ></a><a href="#sa"><img SRC="charts_down.gif" ></a>
Pressure coupling</h3>

<dl>
<h4>
pcoupl:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
No pressure coupling. This means a fixed box size.</dd>

<dt>
<b>isotropic</b></dt>

<dd>
Pressure coupling with time constant <b>tau_p</b> [ps]. The compressibility
and reference pressure are set with
<b>compressibility</b> [1/bar] and
<b>ref_p</b> [bar], one value is needed.</dd>

<dt>
<b>semiisotropic</b></dt>

<dd>
Pressure coupling which is isotropic in the x and y direction, but different
in the z direction. This can be useful for membrane simulations. 2 values
are needed for x/y and z directions respectively.</dd>

<dt>
<b>anisotropic</b></dt>

<dd>
Idem, but 3 values are needed for x, y and z directions respectively. Beware
that isotropic scaling can lead to extreme deformation of the simulation
box.</dd>

<dt>
<b>surface-tension</b></dt>

<dd>
Surface tension couling for surfaces parallel to the xy-plane. Uses normal
pressure coupling for the z-direction, while the surface tension is coupled
to the x/y dimensions of the box. The first <b>ref_p</b> value is the reference
surface tension times the number of surfaces [bar nm], the second value
is the reference z-pressure [bar]. The two <b>compressibility</b> [1/bar]
values are the compressibility in the x/y and z direction respectively.
The value for the z-compressibility should be reasonably accurate since
it influences the converge of the surface-tension, it can also be set to
zero to have a box with constant height.</dd>

<dt>
<b>triclinic</b></dt>

<dd>
Not supported yet.</dd>
</dl>

<h4>
npcmemory: (1) [steps]</h4>

<dd>
memory for running average to couple</dd>

<h4>
tau_p: (1) [ps]</h4>

<dd>
time constant for coupling</dd>

<h4>
compressibility: [1/bar]</h4>

<dd>
compressibility (NOTE: this is now really in 1/bar)</dd>

<h4>
ref_p: [bar]</h4>

<dd>
reference pressure for coupling</dd>
</dl>
<a NAME="sa"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#pc"><img SRC="charts_up.gif" ></a><a href="#vel"><img SRC="charts_down.gif" ></a>
Simulated annealing</h3>

<dl>
<h4>
annealing:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
No simulated annealing.</dd>

<dt>
<b>yes</b></dt>

<dd>
Simulated annealing to 0 [K] at time <b>zero_temp_time</b> (ps). Reference
temperature for the Berendsen-thermostat is
<b><a href="#tc">ref_t</a></b>
x (1 - time / <b>zero_temp_time</b>), time constant is <b>tau_t</b> [ps].
Note that the reference temperature will not go below 0 [K], i.e. after
<b>zero_temp_time</b> (if it is positive) the reference temperature will
be 0 [K]. Negative <b>zero_temp_time</b> results in heating, which will
go on indefenitely.</dd>
</dl>

<h4>
zero_temp_time: (0) [ps]</h4>

<dd>
time at which temperature will be zero (can be negative). Temperature during
the run can be seen as a straight line going through T=<b><a href="#tc">ref_t</a></b>
[K] at t=0 [ps], and T=0 [K] at t=<b>zero_temp_time</b> [ps]. Look in our
<a href="../gmxfaq.html#simann">FAQ</a> for a schematic graph of temperature
vs. time.</dd>
</dl>
<a NAME="vel"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#sa"><img SRC="charts_up.gif" ></a><a href="#sol"><img SRC="charts_down.gif" ></a>
Velocity generation</h3>

<dl>
<h4>
gen_vel:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
Do not generate velocities at startup. The velocities are set to zero when
there are no velocities in the input structure file.</dd>

<dt>
<b>yes</b></dt>

<dd>
Generate velocities according to a Maxwell distribution at temperature
<b>gen_temp</b> [K], with random seed <b>gen_seed</b>. This is only meaningful
with integrator <b><a href="#run">md</a></b>.</dd>
</dl>

<h4>
gen_temp: (300) [K]</h4>

<dd>
temperature for Maxwell distribution</dd>

<h4>
gen_seed: (173529) [integer]</h4>

<dd>
used to initialize random generator for random velocities</dd>
</dl>
<a NAME="sol"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#vel"><img SRC="charts_up.gif" ></a><a href="#bond"><img SRC="charts_down.gif" ></a>
Solvent optimization</h3>

<dl>
<h4>
solvent_optimization:</h4>

<dl compact>
<dt>
<b>&lt;empty></b></dt>

<dd>
Do not use water specific non-bonded optimizations</dd>

<dt>
<b>&lt;solvent molecule name></b></dt>

<dd>
Use water specific non-bonded optimizations. This string should match the
solvent molecule name in your topology. Check your run time to see if it
is faster.</dd>
</dl>

<h4>
nsatoms: (3)</h4>

<dd>
Number of atoms in solvent model. (Not implemented for non-three atom models)</dd>
</dl>
<a NAME="bond"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#sol"><img SRC="charts_up.gif" ></a><a href="#nmr"><img SRC="charts_down.gif" ></a>
Bonds</h3>

<dl>
<h4>
constraints:</h4>

<dl compact>
<dt>
<b>none</b></dt>

<dd>
No constraints, i.e. bonds are represented by a harmonic or a morse potential
(depending on the setting of <b>morse</b>) and angles by a harmonic potential.</dd>

<dt>
<b>hbonds</b></dt>

<dd>
Only constrain the bonds with H-atoms.</dd>

<dt>
<b>all-bonds</b></dt>

<dd>
Constrain all bonds.</dd>

<dt>
<b>h-angles</b></dt>

<dd>
Constrain all bonds and constrain the angles that involve H-atoms by adding
bond-constraints.</dd>

<dt>
<b>all-angles</b></dt>

<dd>
Constrain all bonds and constrain all angles by adding bond-constraints.</dd>
</dl>

<h4>
constraint_alg:</h4>

<dl compact>
<dt>
<b>lincs</b></dt>

<dd>
LINear Constraint Solver. The accuracy in set with
<b>lincs_order</b>,
which sets the number of matrices in the expansion for the matrix inversion,
4 is enough for a "normal" MD simulation, 8 is needed for LD with large
timesteps. If a bond rotates more than
<b>lincs_warnangle</b> [degrees]
in one step, a warning will be printed both to the log file and to <tt>stderr</tt>.
Lincs should not be used with coupled angle constraints.</dd>

<dt>
<b>shake</b></dt>

<dd>
Shake is slower and less stable than Lincs, but does work with angle constraints.
The relative tolerance is set with <b>shake_tol</b>, 0.0001 is a good value
for "normal" MD.</dd>
</dl>

<h4>
unconstrained_start:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
apply constraints to the start configuration</dd>

<dt>
<b>yes</b></dt>

<dd>
do not apply constraints to the start configuration</dd>
</dl>
<a NAME="bond2"></a>
<h4>
shake_tol: (0.0001)</h4>

<dd>
relative tolerance for shake</dd>

<h4>
lincs_order: (4)</h4>

<dd>
Highest order in the expansion of the constraint coupling matrix</dd>

<h4>
lincs_warnangle: (30) [degrees]</h4>

<dd>
maximum angle that a bond can rotate before Lincs will complain</dd>

<h4>
nstlincsout: (1000) [steps]</h4>

<dd>
frequency to output constraint accuracy in log file</dd>

<h4>
morse:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
bonds are represented by a harmonic potential</dd>

<dt>
<b>yes</b></dt>

<dd>
bonds are represented by a morse potential</dd>
</dl>
</dl>
<a NAME="nmr"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#bond"><img SRC="charts_up.gif" ></a><a href="#free"><img SRC="charts_down.gif" ></a>
NMR refinement</h3>

<dl>
<h4>
disre:</h4>

<dl compact>
<dt>
<b>none</b></dt>

<dd>
no distance restraints (ignore distance restraints information in topology
file)</dd>

<dt>
<b>simple</b></dt>

<dd>
simple (per-molecule) distance restraints</dd>

<dt>
<b>ensemble</b></dt>

<dd>
distance restraints over an ensemble of molecules</dd>
</dl>

<h4>
disre_weighting:</h4>

<dl compact>
<dt>
<b>equal</b></dt>

<dd>
divide the restraint force equally over all atom pairs in the restraint</dd>

<dt>
<b>conservative</b></dt>

<dd>
the forces are the derivative of the restraint potential, this results
in an r<sup>-7</sup> weighting of the atom pairs</dd>
</dl>

<h4>
disre_mixed:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
the violation used in the calculation of the restraint force is the time
averaged violation</dd>

<dt>
<b>yes</b></dt>

<dd>
the violation used in the calculation of the restraint force is the square
root of the time averaged violation times the instantaneous violation</dd>
</dl>

<h4>
disre_fc: (1000) [<sup>kJ</sup>/<sub>mol nm<sup>2</sup></sub>]</h4>

<dd>
force constant for distance restraints, which is multiplied by a (possibly)
different factor for each restraint</dd>

<h4>
disre_tau: (10) [ps]</h4>

<dd>
time constant for distance restraints running average</dd>

<h4>
nstdisreout: (100) [steps]</h4>

<dd>
frequency to write the running time averaged and instantaneous distances
of all atom pairs involved in restraints to the energy file (can make the
energy file very large)</dd>
</dl>
<a NAME="free"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#nmr"><img SRC="charts_up.gif" ></a><a href="#neq"><img SRC="charts_down.gif" ></a>
Free energy</h3>

<dl>
<h4>
free_energy:</h4>

<dl compact>
<dt>
<b>no</b></dt>

<dd>
Only use topology A.</dd>

<dt>
<b>yes</b></dt>

<dd>
Change the system from topology A (lambda=0) to topology B (lambda=1) and
calculate the free energy difference. The starting value of lambda is <b>init_lambda</b>
the increase per time step is <b>delta_lambda</b>.</dd>
</dl>

<h4>
init_lambda: (0)</h4>

<dd>
starting value for lambda</dd>

<h4>
delta_lambda: (0)</h4>

<dd>
increase per timestep for lambda</dd>
</dl>
<a NAME="neq"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#free"><img SRC="charts_up.gif" ></a><a href="#ef"><img SRC="charts_down.gif" ></a>
Non-equilibrium MD</h3>

<dl>
<h4>
acc_grps:</h4>

<dd>
groups for constant acceleration (e.g.: <tt>Protein Sol</tt>) all atoms
in groups Protein and Sol will experience constant acceleration as specified
in the <b>accelerate</b> line</dd>

<h4>
accelerate: (0) [nm/ps<sup>2</sup>]</h4>

<dd>
acceleration for <b>acc_grps</b>; x, y and z for each group (e.g. <tt>0.1
0.0 0.0 -0.1 0.0 0.0</tt> means that first group has constant acceleration
of 0.1 nm/ps<sup>2</sup> in X direction, second group the opposite).</dd>

<h4>
freezegrps:</h4>

<dd>
Groups that are to be frozen (i.e. their X, Y, and/or Z position will not
be updated; e.g. <tt>Lipid SOL</tt>). <b>freezedim</b> specifies for which
dimension the freezing applies.</dd>

<h4>
freezedim:</h4>

<dd>
dimensions for which groups in <b>freezegrps</b> should be frozen, specify
<tt>Y</tt> or <tt>N</tt> for X, Y and Z and for each group (e.g. <tt>Y
Y N N N N</tt> means that particles in the first group can move only in
Z direction. The particles in the second group can move in any direction).</dd>
</dl>
<a NAME="ef"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#neq"><img SRC="charts_up.gif" ></a><a href="#user"><img SRC="charts_down.gif" ></a>
Electric fields</h3>

<dl>
<h4>
E_x (0) [V/nm]<b> ; E_y </b>(0) [V/nm]<b> ; E_z: </b>(0) [V/nm]</h4>

<dd>
strength of constant electric field in resp. X, Y and Z direction</dd>

<h4>
E_xt <b>; E_yt ; E_zt:</b></h4>

<dd>
not implemented yet</dd>
</dl>
<a NAME="user"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#ef"><img SRC="charts_up.gif" ></a><a href="#idx"><img SRC="charts_down.gif" ></a>
User defined thingies</h3>

<dl>
<h4>
user1_grps <b>; user2_grps ; user3_grps:</b></h4>

<h4>
userint1 (0)<b> ; userint2 </b>(0)<b> ; userint3 </b>(0)<b> ; userint4:
</b>(0)</h4>

<h4>
userreal1 (0)<b> ; userreal2 </b>(0)<b> ; userreal3 </b>(0)<b> ; userreal4:
</b>(0)</h4>

<dd>
These you can use if you hack out code. You can pass integers and reals
to your subroutine. Check the inputrec definition in
<tt>src/include/types/inputrec.h</tt></dd>
</dl>

<hr><a NAME="idx"></a>
<h3>
<a href="#top"><img SRC="charts_cont.gif" ></a><a href="#idx"><img SRC="charts_idx.gif" ></a><a href="#user"><img SRC="charts_up.gif" ></a><a href="#bot"><img SRC="charts_down.gif" ></a>
Index</h3>
<!--
Be aware that these links take you to the <b>top of the section</b> in
which the parameter is mentioned. For some <b>long sections</b> you
might have to <b>scroll down</b> in your browser window to see the
desired parameter.
</P>
--><multicol COLS=4><a href="#neq">acc_grps</a>
<br><a href="#neq">accelerate</a>
<br><a href="#sa">annealing</a>
<br><a href="#el2">bDispCorr</a>
<br><a href="#nl">box</a>
<br><a href="#pc">compressibility</a>
<br><a href="#bond">constraint_algorithm</a>
<br><a href="#bond">constraints</a>
<br><a href="#el">coulombtype</a>
<br><a href="#pp">cpp</a>
<br><a href="#pp">define</a>
<br><a href="#free">delta_lambda</a>
<br><a href="#nl">deltagrid</a>
<br><a href="#nmr">disre</a>
<br><a href="#nmr">disre_weighting</a>
<br><a href="#nmr">disre_mixed</a>
<br><a href="#nmr">disre_fc</a>
<br><a href="#nmr">disre_tau</a>
<br><a href="#run">dt</a>
<br><a href="#em">emstep</a>
<br><a href="#em">emtol</a>
<br><a href="#out">energygrps</a>
<br><a href="#el2">epsilon_r</a>
<br><a href="#el2">ewald_rtol</a>
<br><a href="#ef">E_x</a>
<br><a href="#ef">E_xt</a>
<br><a href="#ef">E_y</a>
<br><a href="#ef">E_yt</a>
<br><a href="#ef">E_z</a>
<br><a href="#ef">E_zt</a>
<br><a href="#el2">fourier_nx</a>
<br><a href="#el2">fourier_ny</a>
<br><a href="#el2">fourier_nz</a>
<br><a href="#free">free_energy</a>
<br><a href="#neq">freezedim</a>
<br><a href="#neq">freezegrps</a>
<br><a href="#el2">gauss_width</a>
<br><a href="#vel">gen_seed</a>
<br><a href="#vel">gen_temp</a>
<br><a href="#vel">gen_vel</a>
<br><a href="#pp">include</a>
<br><a href="#free">init_lambda</a>
<br><a href="#run">integrator</a>
<br><a href="#ld">ld_fric</a>
<br><a href="#ld">ld_seed</a>
<br><a href="#ld">ld_temp</a>
<br><a href="#bond2">lincs_order</a>
<br><a href="#bond2">lincs_warnangle</a>
<br><a href="#bond2">morse</a>
<br><a href="#el2">niter</a>
<br><a href="#pc">npcmemory</a>
<br><a href="#em">nstcgsteep</a>
<br><a href="#run">nstcomm</a>
<br><a href="#nmr">nstdisreout</a>
<br><a href="#out">nstenergy</a>
<br><a href="#run">nsteps</a>
<br><a href="#out">nstfout</a>
<br><a href="#bond2">nstlincsout</a>
<br><a href="#nl">nstlist</a>
<br><a href="#out">nstlog</a>
<br><a href="#out">nstvout</a>
<br><a href="#out">nstxout</a>
<br><a href="#out">nstxtcout</a>
<br><a href="#nl">ns_type</a>
<br><a href="#tc">ntcmemory</a>
<br><a href="#sol">nsatoms</a>
<br><a href="#el2">optimize_fft</a>
<br><a href="#pc">pcoupl</a>
<br><a href="#el2">pme_order</a>
<br><a href="#pc">ref_p</a>
<br><a href="#tc">ref_t</a>
<br><a href="#el2">rlist</a>
<br><a href="#el2">rcoulomb_switch</a>
<br><a href="#el2">rcoulomb</a>
<br><a href="#el2">rvdw_switch</a>
<br><a href="#el2">rvdw</a>
<br><a href="#bond2">shake_tol</a>
<br><a href="#sol">solvent_optimization</a>
<br><a href="#pc">tau_p</a>
<br><a href="#tc">tau_t</a>
<br><a href="#tc">tc_grps</a>
<br><a href="#tc">tcoupl</a>
<br><a href="#run">tinit</a>
<br><a href="#pp">title</a>
<br><a href="#bond">unconstrained_start</a>
<br><a href="#user">user1_grps</a>
<br><a href="#user">user2_grps</a>
<br><a href="#user">user3_grps</a>
<br><a href="#user">userint1</a>
<br><a href="#user">userint2</a>
<br><a href="#user">userint3</a>
<br><a href="#user">userint4</a>
<br><a href="#user">userreal1</a>
<br><a href="#user">userreal2</a>
<br><a href="#user">userreal3</a>
<br><a href="#user">userreal4</a>
<br><a href="#el">vdwtype</a>
<br><a href="#pp">warnings</a>
<br><a href="#out">xtc_grps</a>
<br><a href="#out">xtc_precision</a>
<br><a href="#sa">zero_temp_time</a>
<br></multicol>
<hr><a NAME="bot"></a>
</body>
</html>
