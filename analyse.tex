\chapter{Analysis.}
\label{ch:analysis}
In this chapter different ways of analysing your trajectory are described. 
The names of the corresponding analysis programs are given. 
Specific info on the in- and output of these programs can be found 
in the on-line manual at {\wwwpage}.
Often the output files are in {\tt xmgr}-format.

First in section~\ref{sec:groups} the group concept in analysis is explained. 
Then the different analysis tools are presented.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Groups in Analysis

\section{Groups in Analysis.}
\label{sec:groups}
\begin{verbatim}
make_ndx
mk_angndx
\end{verbatim}
In chapter~\ref{ch:algorithms} it was explained how {\em groups of
atoms} can be used in the MD-program.  In most analysis programs an
index file is necessary too to select groups to work on. Let's
consider a simulation of a binary mixture of components A and B. When
we want to calculate the radial distribution function (rdf)
$g_{AB}(r)$ of A with respect to B, we have to calculate
\beq
4\pi r^2 g_{AB}(r)	~=~	V~\sum_{i \in A}^{N_A} \sum_{j \in B}^{N_B} P(r)
\eeq
where $V$ is the volume and $P(r)$ is the probability to find a B atom
at a distance $r$ from an A atom.

By having the user define the {\em atom numbers} for groups A and B in
a simple file we can calculate this $g_{AB}$ in the most general way, without
having to make any assumptions in the rdf-program about the type of 
particles. 

Groups can therefore consist of a series of {\em atom numbers}, but in
some cases also of {\em molecule numbers}.  It is also possible to
specify a series of angles by {\em triples} of {\em atom numbers},
dihedrals by {\em quadruplets} of {\em atom numbers} and bonds or
vectors (in a molecule) by {\em couples} of {\em atom numbers}. When
appropriate the type of index file will be specified for the following
analysis programs.  To help creating such index files ({\tt
index.ndx}), there are a couple of programs to generate them, using
either your input configuration or the topology.  To generate an
index file consisting of a series of {\em atom numbers} (as in the
example of $g_{AB}$) use {\tt make\_ndx}. To generate an index file
with angles or dihedrals, use {\tt mk\_angndx}. Of course you can also
make them by hand. The general format is presented here:
{\samepage
\begin{verbatim}
[ Oxygen ]
   1       4       7 
[ Hydrogen ]
   2       3       5       6
   8       9
\end{verbatim}}

First the group name is written between square brackets.
The following atom numbers may be spread out over as many lines as you like.
The atom numbering starts at 1. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Looking at your trajectory

\section{Looking at your trajectory}
\label{sec:lookwhostalking}
\begin{verbatim}
ngmx
\end{verbatim}

\begin{figure}
\centerline{
{\psfig {figure=plots/ngmxdump.eps,width=8cm,angle=90}}}
\caption{The window of {\tt ngmx} showing a box of water.}
\label{fig:ngmxdump}
\end{figure}

Before analysing your trajectory it is often informative to look at
your trajectory first. There is a special graphics program {\tt ngmx}
to show your binary trajectory. It is also possible to generate a
hard-copy in Encapsulated Postscript format, see
fig.~\ref{fig:ngmxdump}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% General properties

\section{General properties}
\label{sec:genprop}
\begin{verbatim}
g_energy
g_com
\end{verbatim}
To analyse some or all {\em energies} and other properties, such as
{\em total pressure}, {\em pressure tensor}, {\em density}, {\em
box-volume} and {\em box-sizes}, use the program {\tt g\_energy}.  A
choice can be made from a list a set of energies, like potential,
kinetic or total energy, or individual contributions, like
Lennard-Jones or dihedral energies.

The {\em centre-of-mass velocity}, defined as
\beq
{\bf v}_{com} = {1 \over M} \sum_{i=1}^N m_i {\bf v}_i
\eeq
with $M = \sum_{i=1}^N m_i$ the total mass of the system, can be
monitored in time by the program {\tt g\_com}. It is however
recommended to remove the centre-of-mass velecity every step (see
chapter~\ref{ch:algorithms})!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Radial distribution functions 

\section{Radial distribution functions}
\label{sec:rdf}
\begin{verbatim}
g_rdf
\end{verbatim}
The {\em radial distribution function} (rdf) or pair correlation
function $g_{AB}(r)$ between particles of type $A$ and $B$ is defined
in the following way:
\newcommand{\dfrac}[2]{\displaystyle \frac{#1}{#2}}
\beq
\begin{array}{rcl}
g_{AB}(r)&=&	\dfrac{< \rho_B(r)>}{<\rho_B>_{local}}		\\
	 &=&	\dfrac{1}{<\rho_B>_{local}}\dfrac{1}{N_A}
	 	\sum_{i \in A}^{N_A} \sum_{j \in B}^{N_B} 
		\dfrac{\delta( r_{ij} - r )}{4 \pi r^2}		\\
\end{array}
\eeq
with $< \rho_B(r)>$ the particle density of type $B$ at a distance $r$
around particles $A$, and $<\rho_B>_{local}$ the particle density of
type $B$ averaged over all spheres around particles $A$ with radius
$r_{max}$ (see fig.~\ref{fig:rdfex}C).

\begin{figure}
\centerline{
{\psfig {figure=plots/rdf.eps,width=7cm,angle=270}}}
\caption[Definition of slices in {\tt g\_rdf}.]{Definition of slices in {\tt g\_rdf}: A. $g_{AB}(r)$. B. $g_{AB}(r,\theta)$. The slices are coloured grey. C. Normalization $<\rho_B>_{local}$. D. Normalization $<\rho_B>_{local,\:\theta }$. Normalization volumes are coloured grey.}
\label{fig:rdfex}
\end{figure}

Usually the value of $r_{max}$ is half of the boxlength. 
The averaging is also performed in time. 
In practice the analysis program {\tt g\_rdf} divides 
the system into spherical slices (from $r$ to $r+dr$, 
see fig.~\ref{fig:rdfex}A) and makes a histogram in stead of the 
$\delta$-function. An example of the rdf of Oxygen-Oxygen 
in SPC-water~\cite{Berendsen81} is given in fig.~\ref{fig:rdf}.

\begin{figure}
\centerline{
{\psfig {figure=plots/rdfO_O.eps,width=7cm,angle=270}}}
\caption{$g_{OO}(r)$ for Oxygen-Oxygen of SPC-water.}
\label{fig:rdf}
\end{figure}

With {\tt g\_rdf} it is also possible to calculate an angle dependent rdf 
$g_{AB}(r,\theta)$, where the angle $\theta$ is defined with respect to a 
certain laboratory axis ${\bf e}$, see fig.~\ref{fig:rdfex}B.
\bea 
g_{AB}(r,\theta) &=& {1 \over <\rho_B>_{local,\:\theta }} {1 \over N_A} \sum_{i \in A}^{N_A} \sum_{j \in B}^{N_B} {\delta( r_{ij} - r ) \delta(\theta_{ij} -\theta) \over 2 \pi r^2 sin(\theta)}\\
cos(\theta_{ij}) &=& {{\bf r}_{ij} \cdot {\bf e} \over \|r_{ij}\| \;\| e\| }
\eea
This $g_{AB}(r,\theta)$ is useful for analysing anisotropic systems. 
Note that in this case the normalization $<\rho_B>_{local,\:\theta}$ is 
the average density in all angle slices from $\theta$ to $\theta + d\theta$ 
up to $r_{max}$, so angle dependent, see fig.~\ref{fig:rdfex}D.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Correlation functions 

\section{Correlation functions}
\label{sec:corr}

\subsection{Theory of correlation functions}
The theory of correlation functions is well established~\cite{Allen87}.
However we want to describe here the implementation of the various 
\myindex{correlation function} flavors in the {\gromacs} code.
The definition of the \myindex{autocorrelation function} (ACF)
$C_f(t)$ for a property $f(t)$ is
\beq
C_f(t)	~=~	\left<f(\xi) f(\xi+t)\right>_{\xi}
\label{eqn:corr}
\eeq
where the notation on the right hand side means averaging over $\xi$, i.e. over
time origins.
It is also possible to compute cross-correlation function from two properties
$f(t)$ and $g(t)$:
\beq
C_{fg}(t) ~=~ 	\left<f(\xi) g(\xi+t)\right>_{\xi}
\eeq
however, in {\gromacs} there is no standard mechanism to do this
({\bf note:} you can use the {\tt xmgr} program to compute cross correlations).
The integral of the correlation function over time is the 
\myindex{correlation time} $\tau_f$:
\beq
\tau_f	~=~	\int_0^{\infty} C_f(t) {\rm d} t
\label{eqn:corrtime}
\eeq

In practice correlation functions are calculated based on data points with
discrete time intervals {$\Delta$t}, so that the ACF from an MD simulation is:
\beq
C_f(j\Delta t)	~=~	\frac{1}{N-j}\sum_{i=0}^{N-1-j} f(i\Delta t) f((i+j)\Delta t)
\label{eqn:corrmd}
\eeq
where $N$ is the number of available time frames for the calculation.
The resulting ACF is
obviously only available at time points with the same interval {$\Delta$t}.
Since for many applications it is necessary to know  the short time behaviour
of the ACF (e.g. the first 10 ps) this often means that we have to save the
atomic coordinates with short intervals.
Another implication of \eqnref{corrmd} is that in principle we can not compute
all points of the ACF with the same accuracy, since we have $N-1$ data points
for $C_f(\Delta t)$ but only 1 for $C_f((N-1)\Delta t)$. However, if we decide to
compute only an ACF of length $M\Delta t$, where $M \leq N/2$ we can compute 
all points with the same statistical accuracy:
\beq
C_f(j\Delta t)	~=~ \frac{1}{M}\sum_{i=0}^{N-1-M} f(i\Delta t)f((i+j)\Delta t)
\eeq
here of course $j < M$.
$M$ is sometimes referred to as the \myindex{time lag} of the correlation function. 
When we decide to do this, we intentionally do not use all the available points
for very short time intervals ($j << M$), but it makes it easier to interpret
the results.
Another aspect that may not be neglected when computing
ACFs from simulation, is that usually the time origins $\xi$ (\eqnref{corr})
are not statistically independent, which may introduce a bias in the results.
This can be tested using a block-averaging procedure, where only time origins
with a spacing at least the length of the time lag are included, e.g. using 
$k$ time origins with spacing of $M\Delta t$ (where $kM \leq N$):
\beq
C_f(j\Delta t)	~=~ \frac{1}{k}\sum_{i=0}^{k-1} f(iM\Delta t)f((iM+j)\Delta t)
\eeq
However, one
needs very long simulations to get good accuracy this way, because there are 
many fewer points that contribute to the ACF.

\subsection{Using FFT for computation of the ACF}
The computational cost for calculating an ACF according to \eqnref{corrmd}
is proportional to $N^2$, which is considerable. However, this can be improved
by using fast fourier transforms to do the convolution~\cite{Allen87}.

\subsection{Special forms of the ACF}
There are some important varieties on the ACF, e.g. the ACF of a vector \ve{p}:
\beq
C_{\ve{p}}(t) ~=~	\int_0^{\infty} P_n(\cos\angle\left(\ve{p}(t),\ve{p}(t+\xi)\right) {\rm d} \xi
\label{eqn:corrleg}
\eeq
where $P_n(x)$ is the $n^{th}$ order Legendre polynomial
\footnote{$P_0(x) = 1$, $P_1(x) = x$, $P_2(x) = (3x^2-1)/2$}.
Such correlation times 
can actually be obtained experimentally using e.g. NMR or other relaxation 
experiments. {\gromacs} can compute correlations using 
the 1${st}$ and 2$^{nd}$ order Legendre polynomial (\eqnref{corrleg}).
This can a.o. be used for rotational autocorrelation ({\tt g\_rotacf}), 
dipole autocorrelation ({\tt g\_dipoles}).

In order to study torsion angle dynamics we define a dihedral 
autocorrelation function as~\cite{Spoel97a}:
\beq
C(t)	~=~	\left< \cos(\theta(\tau)-\theta(\tau+t))\right>_{\tau}
\label{eqn:coenk}
\eeq
Note that this is not a  product of two functions 
as is generally used for correlation
functions, but it may be rewritten as the sum of two products:
\beq
C(t)	~=~	\left<\cos(\theta(\tau))\cos(\theta(\tau+t))\,+\,\sin(\theta(\tau))\sin(\theta(\tau+t))\right>_{\tau}
\label{eqn:cot}
\eeq

\subsection{Some Applications}
The program {\tt g\_velacc} calculates this {\em Velocity AutoCorrelation 
Function}.
\beq
C_{\ve{v}} (\tau) ~=~ < {\ve{v}}_i(\tau) \cdot {\ve{v}}_i(0) >_{i \in A}
\eeq
The self diffusion coefficient can be calculated using the Green-Kubo 
relation~\cite{Allen87}
\beq
D_A ~=~ {1\over 3} \int_0^{\infty} < {\bf v}_i(t) \cdot {\bf v}_i(0) >_{i \in A} \; dt
\eeq
which is just the integral of the velocity autocorrelation function.
There is a widely held belief that the velocity ACF converges faster than the mean
square displacement (\secref{msd}), which can also be used for the computation of 
diffusion constants. However, Allen \& Tildesly~\cite{Allen87} 
warn us that the long time 
contribution to the velocity ACF can not be ignored, so care must be taken.

Another important quantity is the dipole correlation time. The {\em dipole 
correlation function} for particles $A$ is calculated as follows by 
{\tt g\_dipoles}:
\beq
C_{\mu} (\tau) ~=~ < {\bf \mu}_i(\tau) \cdot {\bf \mu}_i(0) >_{i \in A}
\eeq
with ${\bf \mu}_i = \sum_{j \in i} {\bf r}_j q_j$. The dipole correlation time 
can be computed using \eqnref{corrtime}.
For some applications see~\cite{Spoel98a}.

The \myindex{viscosity} of a liquid can be related to the correlation 
time of the Pressure tensor $\ve{P}$~\cite{PSmith93c,Balasubramanian96}.
{\tt g\_energy} can compute the viscosity, but in our experience this is not very
accurate (actually the values do not converge...).

\subsection{Mean Square Displacement}
\label{sec:msd}
To determine the self \myindex{diffusion coefficient} $D_A$ of particles $A$ one
can use the Einstein relation~\cite{Allen87} \beq \lim_{t \rightarrow
\infty} <|{\bf r}_i(t) - {\bf r}_i(0)|^2>_{i \in A} ~=~ 6 D_A t \eeq
This {\em Mean Square Displacement} and $D_A$ are calculated by the
program {\tt g\_msd}. For molecules consisting of more than one atom,
${\bf r}_i$ is the centre of mass positions. In that case you should
use an index file with molecule numbers! The program can also be used
for calculating diffusion in one or two dimensions. This is useful for
studying lateral diffusion on interfaces. 

An example of the mean square displacement of SPC-water is given in
fig.~\ref{fig:msdwater}.

\begin{figure}
\centerline{
{\psfig {figure=plots/msdwater.eps,width=6.5cm,angle=270}}}
\caption{Mean Square Displacement of SPC-water.}
\label{fig:msdwater}
\end{figure}

% 
%%%%%%%%%%%%%%%%%%%%% Bonds, angles and dihedral %%%%%%%%%%%%%%%%%%%
% 
\section{Bonds, angles and dihedrals}
\label{sec:bad}
\begin{verbatim}
g_bond
g_angle
g_sgangle
\end{verbatim}
To monitor specific {\em bonds} in your molecules during time, the program 
{\tt g\_bond} calculates the distribution of the bondlength in time. 
The index file consists of pairs of atom numbers, for example
{\samepage
\begin{verbatim}
[ bonds_1 ]
 1     2
 3     4
 9    10
[ bonds_2 ]
12    13
\end{verbatim}}

The program {\tt g\_angle} calculates the distribution of {\em angles} and 
{\em dihedrals} in time. It also gives the average angle or dihedral. 
The index file consists of triplets or quadruplets of atom numbers:
{\samepage
\begin{verbatim}
[ angles ]
 1     2     3
 2     3     4
 3     4     5
[ dihedrals ]
 1     2     3     4
 2     3     5     5
\end{verbatim}}

For the dihedral angles you can use eighter the ``biochemical convention'' 
($\phi = 0 \equiv cis$) or ``polymer convention'' ($\phi = 0 \equiv trans$), 
see fig~\ref{fig:dih_def}.

\begin{figure}
\centerline{
{\psfig {figure=plots/dih_def.eps,width=3.5cm,angle=270}}}
\caption{Dihedral conventions: A. ``Biochemical
convention''. B. ``Polymer convention''.}
\label{fig:dih_def}
\end{figure}

To follow specific {\em angles} in time between two vectors, a vector
and a plane or two planes (defined by 2, resp. 3 atoms inside your
molecule, see fig.~\ref{fig:sgangle}A, B, C), use the program {\tt
g\_sgangle}.

\begin{figure}
\centerline{
{\psfig {figure=plots/sgangle.eps,width=6.5cm,angle=270}}}
\caption[Options of {\tt g\_sgangle}.]{Options of {\tt g\_sgangle}: A. Angle between 2 vectors. B. Angle between a vector and the normal of a plane. C. Angle between two planes. D. Distance between the geometrical centres of 2 planes. E. Distances between a vector and the centre of a plane.}
\label{fig:sgangle}
\end{figure}

For planes it uses the normal vector perpendicular to the plane.  It
can also calculate the {\em distance} $d$ between the geometrical
centre of two planes (see fig.~\ref{fig:sgangle}D), and the distances
$d_1$ and $d_2$ between 2 atoms (of a vector) and the centre of a
plane defined by 3 atoms (see fig.~\ref{fig:sgangle}D). It further
calculates the distance $d$ between the centre of the plane and the
middle of this vector.  Depending on the input groups (i.e. groups of
2 or 3 atom numbers), the program decides what angles and distances to
calculate. For example, the index-file could look like this:
{\samepage
\begin{verbatim}
[ a_plane ]
 1     2     3
[ a_vector ]
 3     4     5
\end{verbatim}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Radius of gyration and distances

\section{Radius of gyration and distances}
\label{sec:rg}
\begin{verbatim}
g_gyrate
g_sgangle
g_mindist
g_mdmat
xpm2ps
\end{verbatim}
To have a rough measure for the compactness of a structure, you can calculate 
the {\em radius of gyration} with the program {\tt g\_gyrate} as follows:
\beq
R_g ~=~ \left({\frac{\sum_i {\bf r}_i^2 m_i}{\sum_i m_i}}\right)^{\half}
\label{eq:rg}
\eeq
where $m_i$ is the mass of atom $i$ and ${\bf r}_i$ the position of 
atom $i$ with respect to the center of mass of the molecule. It is especially 
useful to characterize polymer solutions and proteins.

Sometimes it is interesting to plot the {\em distance} between two atoms,
or the {\em minimum} distance between two groups of atoms
(eg.: protein sidechains in a salt bridge). 
To calculate these distances between certain groups there are several 
possibilities:
\begin{description}
\item[$\bullet$] 
The {\em distance between the geometrical centres} of two groups can be 
calculated with {\tt g\_sgangle}, as explained in section~\ref{sec:bad}. 
\item[$\bullet$] 
The {\em minumum distance} between two groups of atoms during time 
can be calculated with the program {\tt g\_mindist}. It also calculates the 
{\em number of contacts} between these groups 
within a certain radius $r_{max}$.
\item[$\bullet$] 
To monitor the {\em minimum distances between residues} 
(see chapter~\ref{ch:top}) within a (protein) molecule, you can use 
the program {\tt g\_mdmat}. This minimum distance between two residues
A$_i$ and A$_j$ is defined as the smallest distance between any pair of 
atoms (i $\in$ A$_i$, j $\in$ A$_j$).
The output is a symmetrical matrix of smallest distances 
between all residues.
To visualize this matrix, you can use a program such as {\tt xv}.
If you want to view the axes and legend or if you want to print
the matrix, you can convert it with 
{\tt xpm2ps} into a Postscript picture, see fig.~\ref{fig:mdmat}.
\begin{figure}
\centerline{
\psfig {figure=plots/distm.eps,width=6.5cm}}
\caption{A minimum distance matrix for a peptide~\protect\cite{Spoel96b}.}
\label{fig:mdmat}
\end{figure}

Plotting these matrices for different timeframes, one can analyse changes 
in the structure, and e.g. forming of salt bridges.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Root mean square deviations 

\section{Root mean square deviations in structure}
\label{sec:rmsd}
\begin{verbatim}
g_rms
g_rmsdist
\end{verbatim}
The {\em root mean square deviation} ($RMSD$) of certain atoms in a molecule
with respect to a reference structure can be calculated with the program 
{\tt g\_rms} by least-square fitting the structure to the reference structure
($t_2 = 0$) and subsequently calculating the $RMSD$ (eq.~\ref{eq:rmsd}).
\beq
RMSD(t_1,t_2) ~=~ \left[\frac{1}{N} \sum_{i=1}^N ({\bf r}_i(t_1)-{\bf r}_i(t_2))^2 \right]^{\frac{1}{2}}
\label{eq:rmsd}
\eeq
where ${\bf r}_i(t)$ is the position of atom $i$ at time $t$.
{\bf NOTE} that fitting does not have to use the same atoms as the calculation
of the $RMSD$; eg.: a protein is usually fitted on the backbone atoms
(N,C$_{\alpha}$,C), but the $RMSD$ can be computed of the backbone
or of the whole protein.

Instead of comparing the structures to the initial structure at time $t=0$ 
(so for example a crystal structure), one can also calculate eq.~\ref{eq:rmsd} 
with a structure at time $t_2=t_1-\tau$.
This gives some insight in the mobility as a function of $\tau$.
Also a matrix can be made with the $RMSD$ as a function of $t_1$ and $t_2$,
this gives a nice graphical impression of a trajectory.
If there are transitions in a trajectory, they will clearly show up in
such a matrix.

Alternatively the $RMSD$ can be computed using a fit-free method with the 
program {\tt g\_rmsdist}:
\beq
RMSD(t)	~=~	\left[\frac{1}{N^2}\sum_{i=1}^N	\sum_{j=1}^N	({\bf r}_{ij}(t)-{\bf r}_{ij}(0))^2\right]^{\frac{1}{2}}
\label{eq:rmsdff}
\eeq
where the {\em distance} {\bf r}$_{ij}$ between atoms at time $t$ 
is compared with the distance between the same atoms at time $0$.

In stead of comparing the structures to the initial structure at time $t=0$ 
(so for example a cristal structure), one can also calculate eq.~\ref{eq:rmsd} 
using a timeshift $\tau$:
\beq
RMSD(t;\tau) ~=~ \left[\frac{1}{N} \sum_{i=1}^N ({\bf r}_i(t)-{\bf r}_i(t-\tau))^2 \right]^{\frac{1}{2}}
\label{eq:rmdstau}
\eeq
so comparing to a least-square structure at $t-\tau$. This gives some insight 
in the mobility as a function of $\tau$. Use the program {\tt g\_run\_rms}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Hydrogen bonds

\section{Hydrogen bonds}
\begin{verbatim}
g_hbond
\end{verbatim}
The program {\tt g\_hbond} analyses the {\em hydrogen bonds} (H-bonds)
between all possible donors D and acceptors A. To determine if an
H-bond exists, a geometrical criterion is used, see also
fig.~\ref{fig:hbond}:
\beq
\begin{array}{rclcl}
r	& \leq	& r_{HB}	& = & 0.35 \mbox{nm}	\\
\alpha	& \leq	& \alpha_{HB}	& = & 60^o 		\\
\end{array}
\eeq

\begin{figure}
\centerline{\psfig{figure=plots/hbond.eps,width=2.5cm,angle=270}}
\caption{Geometrical Hydrogen bond criterion.}
\label{fig:hbond}
\end{figure}

The value of $r_{HB} = 3.5 \AA$ corresponds to the first minimum of the rdf of 
SPC-water (see also fig.~\ref{fig:rdf}).

The program {\tt g\_hbond} analyses all hydrogen bonds existing
between two groups of atoms (which must be either identical or
non-overlapping) or in specified Donor Hydrogen Acceptor triplets, in
the following ways:

\begin{figure}
\centerline{
{\psfig {figure=plots/hbond_insert.eps,width=5cm,angle=270}}}
\caption{Insertion of water into an H-bond. (1) Normal H-bond between
two residues. (2) H-bonding bridge via a water molecule.}
\label{fig:insert}
\end{figure}

\begin{itemize}
\item
Donor-Acceptor distance ($r$) distribution of all H-bonds
\item
Hydrogen-Donor-Acceptor angle ($\alpha$) distribution of all H-bonds 
\item
The total number of H-bonds in each timeframe
\item
\newcommand{\nn}[1]{$n$-$n$+$#1$}
The number of H-bonds in time between residues, devided into groups
\nn{i} where $n$ and $n$+$i$ stand for residue numbers and $i$ goes
from 0 to 6. The group for $i=6$ also includes all H-bonds for
$i>6$. These groups include the \nn{3}, \nn{4} and \nn{5} H-bonds
which provide a measure for the formation of $\alpha$-helices or
$\beta$-turns or strands.
\item
The lifetime of the H-bonds is calculated from the average over all
autocorrelation functions of the existence functions (either 0 or 1)
of all H-bonds:
\beq
C(\tau) ~=~ < s_i(t)~s_i (t + \tau) >
\label{eq:hbcorr}
\eeq
with $s_i(t) = \{0,1\}$ for H-bond $i$ at time $t$. The integral of
$C(\tau)$ gives a rough estimate of the average H-bond lifetime
$\tau_{HB}$:
\beq
\tau_{HB} ~=~ \int_{0}^{\infty} C(\tau) d\tau
\label{eq:hblife}
\eeq
Both the integral and the complete autocorrelaten function $C(\tau)$
will be output, so that more sophisticated analysis (e.g.\@ using
multi-exponential fits) can be used to get better estimates for
$\tau_{HB}$.
\item
An H-bond existence map can be generated of dimensions {\em
\#~H-bonds}$\times${\em \#~frames}.
\item
Index groups are output containing the analyzed groups, all
donor-hydrogen atom pairs and acceptor atoms in these groups,
donor-hydrogen-acceptor triplets involved in hydrogen bonds between
the analyzed groups and all solvent atoms involved in insertion.
\item
Solvent insertion into H-bonds can be analyzed, see
fig.~\ref{fig:insert}. In this case an additional group identifying
the solvent must be selected. The occurrence of insertion will be
indicated in the existence map. Note that insertion into and existence
of a specific H-bond can occur simultaneously and will also be
indicated as such in the existence map.
\end{itemize}

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Protein related items 

\section{Protein related items}
\begin{verbatim}
do_dssp
g_rama
xrama
wheel
\end{verbatim}
To analyse structural changes of a protein, you can calculate the radius of 
gyration or the minimum residue distances during time 
(see section~\ref{sec:rg}), or calculate the RMSD (section~\ref{sec:rmsd}).

You can also look at the changing of {\em secondary structure elements} 
during your run. For this you can use the program {\tt do\_dssp}, which is 
an interface for the commercial program {\tt dssp}~\cite{Kabsch83}. For 
further information, see the {\tt dssp}-manual. A tyical output plot of 
{\tt do\_dssp} is given in fig.~\ref{fig:dssp}.

\begin{figure}
\centerline{
\psfig {figure=plots/dssp.eps,width=12cm}}
\caption{Analysis of the secondary structure elements of a peptide in time.}
\label{fig:dssp}
\end{figure}

One other important analysis of proteins is the so called 
{\em Ramachandran plot}. 
This is the projection of the structure on the two dihedral angles $\phi$ and 
$\psi$ of the protein backbone, see fig.~\ref{fig:phipsi}.

\begin{figure}
\centerline{
\psfig {figure=plots/phipsi.eps,width=5cm}}
\caption{Definition of the dihedral angles $\phi$ and $\psi$ of the protein backbone.}
\label{fig:phipsi}
\end{figure}

To evaluate this Ramachandran plot you can use the program {\tt g\_rama}. 
A typical output is given in fig.~\ref{fig:rama}.

\begin{figure}
\centerline{
{\psfig {figure=plots/rama.eps,width=9cm,angle=270}}}
\caption{Ramachandran plot of a small protein.}
\label{fig:rama}
\end{figure}

It is also possible to generate an {\em animation of the Ramachandran plot} 
in time. This can be of help for analysing certain dihedral transitions 
in your protein. You can use the program {\tt xrama} for this.

When studying $\alpha$-helices 
it is useful to have a {\em helical wheel} projection
of your peptide, to see whether a peptide is amphipatic. This can be done
using the {\tt wheel} program. Two examples are 
plotted in fig.~\ref{fig:wheel}.

\begin{figure}
\centerline{\psfig{figure=plots/hpr-wheel.eps,width=\htw}}
\caption{Helical wheel projection of the N-terminal helix of HPr.}
\label{fig:wheel}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Membrane Related Items

\section{Interface related items}
\begin{verbatim}
g_order
g_density
g_potential
g_coord
\end{verbatim}

When simulating molecules with long carbon tails, it can be
interesting to calculate their average orientation. There are several
flavours of order parameters, most of which are related. The program
{\tt g\_order} can calculate orderparameters using the equation

\begin{equation}
S_{z} = \frac{3}{2}\langle {\cos^2{\theta_z}} \rangle - \frac{1}{2}
\label{eq:Sgr}
\end{equation}
where $\theta_z$ is the angle between the $z$-axis of the simulation
box and the molecular axis under consideration. The latter is defined as the
vector from C$_{n-1}$ to C$_{n+1}$. The parameters $S_x$
and $S_y$ are defined in the same way. The brackets imply averaging over time
and molecules. Order parameters can vary between 1 (full order along
the interface normal) and $-1/2$ (full order perpendicular to the
normal), with a value of zero in the case of isotropic orientation.

The program can do two things for you. It can calculate the order
parameter for each CH$_2$ segment seperately, for any of three axes,
or it can divide the box in slices and calculate the average value of
the order parameter per segment in one slice. The first method gives
an idea of the ordering of a molecule from head to tail, the second
method gives an idea of the ordering as function of the boxlength.

The electrostatic potential ($\psi$) across the interface can be
computed from a trajectory by evaluating the double integral of the
charge density ($\rho(z)$):
\beq
\psi(z) - \psi(-\infty) = - \int_{-\infty}^z dz' \int_{-\infty}^{z'} \rho(z'')dz''/ \epsilon_0 
\label{eq:elpotgr}
\eeq
where the position $z=-\infty$ is far enough in the bulk phase that
the field is zero.  With this method, it is possible to ``split'' the
total potential into separate contributions from lipid and water
molecules. The program {\tt g\_potential} divides the box in slices and
sums all charges of the atoms in each slice. It then integrates this
charge density, giving the electric field, and the electric field,
giving the potential. Charge density, field and potential are written
to {\tt xvgr-}input files.

The program {\tt g\_coord} is a very simple analysis program. All it
does is print the coordinates of selected atoms to three files,
containing respectively the {\em x-, y-} and {\em z-}coordinates of
those atoms. It can also calculate the center of mass of one or more
molecules and print the coordinates of the center of mass to three
files. By itself, this is probably not a very useful analysis, but
having the coordinates of selected molecules or atoms can be very
handy for further analysis, not only in interface systems.

The program {\tt g\_pvd} calculates a lot of properties, among which
the density of a group in particles per unit of volume, but not a
density that takes the mass of the atoms into account. The program
{\tt g\_density} also calculates the density of a group, but takes the
masses into account and gives a plot of the density against a box
axis. This is useful for looking at the distribution of groups or
atoms across the interface.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Chemical shifts

\section{Chemical shifts}
\begin{verbatim}
total
do_shift
\end{verbatim}
You can compute the NMR chemical shifts of protons with the program
{\tt do\_shift}. This is just an \gromacs~interface to the public
domain program {\tt total}~\cite{Williamson93a}. For further
information, read the article.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
