#include <math.h>
#include <string.h>
#include "smalloc.h"
#include "typedefs.h"
#include "macros.h"
#include "random.h"
#include "physics.h"
#include "xvgr.h"
#include "vec.h"
#include "txtdump.h"
#include "ionize.h"
#include "names.h"
#include "futil.h"
#include "ion_data.h"

#define PREFIX "IONIZE: "

enum { ecollPHOTO, ecollINELASTIC, ecollNR };

typedef struct {
  int  z,n,k;
  real fj,sigPh,sigIn,vAuger;
} t_cross_atom;

void dump_ca(FILE *fp,t_cross_atom *ca,int i,char *file,int line)
{
  fprintf(fp,PREFIX"atom %d, z = %d, n = %d, k = %d\n",i,ca->z,ca->n,ca->k);
}

t_cross_atom *mk_cross_atom(FILE *log,t_mdatoms *md,
			    char **atomname[],int Eindex)
{
  t_cross_atom *ca;
  int  *elemcnt;
  char *cc;
  int  i,j;
  
  fprintf(log,PREFIX"Filling data structure for ionization\n");
  fprintf(log,PREFIX"Warning: all fj values set to 0.95 for now\n");
  snew(ca,md->nr);
  snew(elemcnt,NELEM+1);
  for(i=0; (i<md->nr); i++) {
    ca[i].n = 0;
    ca[i].k = 0;
    cc = *(atomname[i]);
    for(j=1; (j<NELEM); j++)
      if (strncmp(cc,element[j].name,strlen(element[j].name)) == 0) {
	ca[i].z = element[j].nel;
	break;
      }
    if (j == NELEM) 
      fatal_error(0,PREFIX"Don't know number of electrons for %s",
		  *atomname[i]);
    elemcnt[j]++;

    ca[i].sigPh = element[ca[i].z].cross[Eindex].photo;
    ca[i].sigIn = element[ca[i].z].cross[Eindex].incoh;
    ca[i].fj    = 0.95;
    switch (ca[i].z) {
    case 6:
      ca[i].vAuger  = 0.904;
      break;
    case 7:
      ca[i].vAuger  = 0.920;
      break;
    case 8:
      ca[i].vAuger  = 0.929;
      break;
    case 16:
      ca[i].vAuger = 1.0;
      break;
    default:
      ca[i].vAuger= -1;
    }
  }
  
  fprintf(log,PREFIX"You have the following elements in your system (%d atoms):\n"PREFIX,md->nr);
  for(j=1; (j<NELEM); j++)
    if (elemcnt[j] > 0)
      fprintf(log,"  %s: %d",element[j].name,elemcnt[j]);
  fprintf(log," atoms\n");

  sfree(elemcnt);
  
  return ca;
}

int number_K(t_cross_atom *ca)
{
  if (ca->z <= 2)
    return ca->z-ca->n;
  else
    return 2-ca->k;
}

int number_L(t_cross_atom *ca)
{
  return ca->k-2+ca->z-ca->n;
}

real cross(int eColl,t_cross_atom *ca)
{
  real c;
  int  nK,nL;
  
  switch (eColl) {
  case ecollPHOTO:
    nK = number_K(ca);
    nL = number_L(ca);
    if (ca->z == 1)
      c = ca->sigPh;
    else if (ca->z == 2)
      c = ca->sigPh*0.5;
    else
      c = (nK*0.5*ca->fj + nL/(ca->z-2)*(1-ca->fj))*ca->sigPh;
    break;
  case ecollINELASTIC:
    c = (ca->z-ca->n)*ca->sigIn/ca->z;
    break;
  default:
    fatal_error(0,"No such collision type %d\n",eColl);
  }
  return c;
}

real prob_L(int eColl,t_cross_atom *ca)
{
  real Pl,Pk,P;
  
  if ((ca->z <= 2) || (ca->z == ca->n))
    return 0;

  switch (eColl) {
  case ecollPHOTO:
    Pl = (ca->k-2+ca->z-ca->n)*(1-ca->fj)/(ca->z-2);
    Pk = (2-ca->k)*ca->fj*0.5;
    P  = Pk/(Pl+Pk);
    break;
  case ecollINELASTIC:
    P = (2-ca->k)/(ca->z-ca->n);
    break;
  default:
    fatal_error(0,"No such collision type %d\n",eColl);
  } 
  return P;
}

double myexp(double x)
{
  if (x < -70)
    return 0.0;
  else
    return exp(x);
}

real ptheta_incoh(int Eindex,real theta) 
     /* theta should be in degrees */
{
  /* These numbers generated by fitting 5 gaussians to the real function
   * that describes the probability for theta.
   * We use symmetry in the gaussian (see 180-angle) therefore there
   * are fewer parameters (only 8 per energylevel).
   */
  static double ppp[5][8] = {
    { -0.00295169, 10.4847, 0.0341099, /*-*/43.1963, 
      -0.0164054,  30.2452, 71.0311,    2.50282 },
    { -0.00370852, 9.02037, 0.100559,  /*-*/42.9962,
      -0.0537891,  35.5077, 71.4305,    1.05515 },
    { -0.00427039, 7.86831, 0.118042,  /*-*/45.9846,
      -0.0634505,  38.6134, 70.3857,    0.240082 },
    { -0.00488796, 5.87988, 0.159574,  /*-*/51.5556,
      -0.0855767,  44.7307, 69.0251,   -0.414604 },
    { -0.00504604, 4.56299, 0.201064,  /*-*/54.8599,
      -0.107153,   48.7016, 68.8212,   -0.487699 }
  };
  double g1,g2,g3,g4,g5,ptheta;

  g1 = myexp(-0.5*sqr((theta-ppp[Eindex][7])/ppp[Eindex][1]));
  g2 = myexp(-0.5*sqr((theta-180+ppp[Eindex][7])/ppp[Eindex][1]));
  g3 = myexp(-0.5*sqr((theta-90)/ppp[Eindex][3]));
  g4 = myexp(-0.5*sqr((theta-ppp[Eindex][6])/ppp[Eindex][5]));
  g5 = myexp(-0.5*sqr((theta-180+ppp[Eindex][6])/ppp[Eindex][5]));

  ptheta = ppp[Eindex][0]*(g1+g2) + ppp[Eindex][2]*g3 + ppp[Eindex][4]*(g4+g5);

  return ptheta;
}

real rand_theta_incoh(int Eindex,int *seed) 
{
#define NINTP 450
#define prev (1-cur)
  static bool bFirst = TRUE;
  static real **intp;
  static int  i,j,cur=1;
  real theta,sum,rrr,dx;
  real g[5],y[2];
  
  dx = 90.0/(real)NINTP;
  if (bFirst) {
    /* Compute cumulative integrals of all probability distributions */
    snew(intp,5);
    for(i=0; (i<5); i++) {
      snew(intp[i],NINTP+1);
      y[prev]    = ptheta_incoh(i,0.0);
      /*sum        = y[prev];*/
      for(j=1; (j<=NINTP); j++) {
	y[cur]     = ptheta_incoh(i,j*dx);
	/*sum       += y[cur];*/
	intp[i][j] = intp[i][j-1] + (y[cur]+y[prev])*dx;
	cur        = prev;
      }
    }
    if (debug) {
      fprintf(debug,"Integrated probability functions for theta incoherent\n");
      for(j=0; (j<NINTP); j++) {
	fprintf(debug,"%10f",dx*j);
	for(i=0; (i<5); i++) 
	  fprintf(debug,"  %10f",intp[i][j]);
	fprintf(debug,"\n");
      }
    }
    bFirst = FALSE;
  }

  rrr = rando(seed);
  for(j=0; (j<NINTP) && (rrr > intp[Eindex][j]); j++)
    ;

  return (j-1+(rrr-intp[Eindex][j-1])/(intp[Eindex][j]-intp[Eindex][j-1]))*dx;
}

bool khole_decay(FILE *log,t_cross_atom *ca,rvec v,int *seed,real dt,int atom)
{
  rvec dv;
  real ndv,factor;
  int  m;
  
  if ((ca->vAuger < 0) || (recoil[ca->z].tau == 0)) {
    dump_ca(stderr,ca,atom,__FILE__,__LINE__);
    exit(1);
  }
  if (rando(seed) < dt/recoil[ca->z].tau) {
    fprintf(log,"DECAY: Going to decay a k hole\n");
    ca->n++;
    ca->k--;
    /* Generate random vector */
    do {
      dv[XX] = 2*rando(seed)-1;
      dv[YY] = 2*rando(seed)-1;
      dv[ZZ] = 2*rando(seed)-1;
      ndv = norm(dv);
    } while (ndv == 0.0);
    factor = ca->vAuger/ndv;
    fprintf(log,"DECAY: factor=%10g, dv = (%8.3f, %8.3f, %8.3f)\n",
	    factor,dv[XX],dv[YY],dv[ZZ]);
    for(m=0; (m<DIM); m++)
      v[m] += dv[m]*factor;
    return TRUE;
  }
  else
    return FALSE;
}

void ionize(FILE *log,t_mdatoms *md,char **atomname[],real t,t_inputrec *ir,
	    rvec v[])
{
  static FILE  *xvg,*ion;
  static char  *leg[] = { "Probability", "Number/Atom", "Total" };
  static bool  bFirst = TRUE;
  static bool  bImpulse = TRUE;
  static real  t0,imax,width,inv_nratoms,rho,nphot,nkdecay,nkd_tot;
  static int   seed,total,ephot;
  static t_cross_atom *ca;
  static int   Eindex=-1;
  static int   Energies[] = { 6, 8, 10, 15, 20 };
#define NENER asize(Energies)
  real r,factor,ndv,E_lost,cross_atom,dvz,rrc;
  real pt,ptot,pphot,pcoll[ecollNR];
  real incoh,incoh_abs,sigmaPincoh;
  rvec dv;
  bool bIonize,bKHole,bL;
  int  nK,nL;
  char *cc;
  int  i,j,k,kk,m,dq,nkhole;
  
  if (bFirst) {
    /* Get parameters for gaussian photon pulse from inputrec */
    t0    = ir->userreal1;  /* Peak of the gaussian pulse            */
    nphot = ir->userreal2;  /* Intensity                             */
    width = ir->userreal3;  /* Width of the peak                     */
    rho   = ir->userreal4;  /* Diameter of the focal spot            */
    seed  = ir->userint1;   /* Random seed for stochastic ionization */
    ephot = ir->userint2;   /* Energy of the photons                 */
    
    if ((width <= 0) || (nphot <= 0))
      fatal_error(0,"Your parameters for ionization are not set properly\n"
		  "width = %f,  nphot = %f",width,nphot);
    
    imax  = (nphot/(M_PI*rho*rho))*1e-10*sqrt(1.0/M_PI)*(2.0/width);

    
    if (seed == 0)
      seed = 1993;
    
    for(Eindex=0; (Eindex < NENER) && (Energies[Eindex] != ephot); Eindex++)
      ;
    if (Eindex == NENER)
      fatal_error(0,PREFIX"Energy level of %d keV not supported",ephot);
    
    /* Initiate cross section data etc. */
    ca    = mk_cross_atom(log,md,atomname,Eindex);
    
    total   = 0;
    nkd_tot = 0;
    inv_nratoms = 1.0/md->nr;

    xvg   = xvgropen("ionize.xvg","Ionization Events","Time (ps)","()");
    xvgr_legend(xvg,asize(leg),leg);
    ion   = ffopen("ionize.log","w");
    
    fprintf(log,PREFIX"Parameters for ionization events:\n");
    fprintf(log,PREFIX"Imax = %g, t0 = %g, width = %g, seed = %d\n"
	    PREFIX"# Photons = %g, rho = %g, ephot = %d (keV), Impulse = %s\n",
	    imax,t0,width,seed,nphot,rho,ephot,yesno_names[bImpulse]);
    fprintf(log,PREFIX"Electron_mass: %10.3e(keV) Atomic_mass: %10.3e(keV)\n"
	    "Speed_of_light: %10.3e(nm/ps)\n",
	    ELECTRONMASS_keV,ATOMICMASS_keV,SPEEDOFLIGHT);
    fflush(log);
    bFirst = FALSE;
  }

  /******************************************************
   *
   *    H E R E    S T A R T S   I O N I Z A T I O N
   *
   ******************************************************/
        
  /* Calculate probability */
  pt          = imax*ir->delta_t*exp(-sqr(2.0*(t-t0)/width));
  dq          = 0;
  nkdecay     = 0;
  
  /* Width of gaussian for probability of incoherent scattering */
  sigmaPincoh = 1/sqrt(44.0);
  
  /* Print time to the file that holds ionization events per atom */
  fprintf(ion,"%12.8f",t);
  where();
  /* Loop over atoms */
  for(i=0; (i<md->nr); i++) {
    /* Loop over collision types */
    bKHole = FALSE;
    for(k=0; (k<ecollNR); k++) {
      /* Determine cross section */
      cross_atom = cross(k,&(ca[i]));
      pcoll[k] = pt*cross_atom;
    }
    /* Total probability of ionisation */
    ptot = 1 - (1-pcoll[ecollPHOTO])*(1-pcoll[ecollINELASTIC]);
    
    /* Check whether to ionize this guy */
    if ((rando(&seed) < ptot) && (ca[i].n < ca[i].z)) {
      clear_rvec(dv);
      
      /* The relative probability for a photoellastic event is given by: */
      pphot = pcoll[ecollPHOTO]/(pcoll[ecollPHOTO]+pcoll[ecollINELASTIC]);
      
      if (rando(&seed) < pphot) 
	k = ecollPHOTO;
      else
	k = ecollINELASTIC;
      
      /* If a random number is smaller than the probability for 
       * an L ionization than do that. Note that the probability
       * may be zero (H, He), but the < instead of <= covers that.
       */
      nK = number_K(&ca[i]);
      nL = number_L(&ca[i]);
      bL = ((rando(&seed) < prob_L(k,&(ca[i]))) && (nL > 0)) || (nK == 0);
      
      switch (k) {
      case ecollPHOTO: {
	/* Select which one to take by yet another random numer */
	real theta,phi;
	
	/* Get parameters for photoelestic effect */
	/* Note that in the article this is called 2 theta */
	theta = DEG2RAD*gauss(70.0,26.0,&seed);
	phi   = 2*M_PI*rando(&seed);
	
	if (bL)
	  E_lost = ephot-recoil[ca[i].z-ca[i].n].E_L;
	else {
	  E_lost = ephot-recoil[ca[i].z-ca[i].n].E_K;
	  if ((ca[i].z > 2) && (nL > 0))
	    bKHole = TRUE;
	}
	if (debug)
	  fprintf(debug,"i = %d, nK = %d, nL = %d, bL = %s, bKHole = %s\n",
		  i,nK,nL,BOOL(bL),BOOL(bKHole));
	if (E_lost < 0) {
	  E_lost  = 0.0;
	  bIonize = FALSE;
	  bKHole  = FALSE;
	}
	else {
	  /* Compute the components of the velocity vector */
	  factor = ((ELECTRONMASS_keV/(ATOMICMASS_keV*md->massT[i]))*
		    (SPEEDOFLIGHT*sqrt(2*E_lost/ELECTRONMASS_keV)));
	  
	  /* Subtract momentum of recoiling electron */
	  dv[XX] -= factor*cos(phi)*sin(theta);
	  dv[YY] -= factor*sin(phi)*sin(theta);
	  dv[ZZ] -= factor*cos(theta);
	  
	  if (debug)
	    pr_rvec(debug,0,"ELL",dv,DIM);
	  
	  bIonize = TRUE;
	}
	break;
      }
      case ecollINELASTIC: {
	real theta,phi,Ebind,Eelec;
	
	if (bL)
	  Ebind = ca[i].n*recoil[ca[i].z].E_L;
	else {
	  Ebind  = recoil[ca[i].z].E_K;
	  if ((ca[i].z > 2) && (nL > 0))
	    bKHole = TRUE;
	}
	theta      = DEG2RAD*rand_theta_incoh(Eindex,&seed);
	Eelec      = (sqr(ephot)/512)*(1-cos(2*theta));
	bIonize    = (Ebind <= Eelec);
	bKHole     = bKHole && bIonize;
	if (debug)
	  fprintf(debug,PREFIX"Ebind: %g, Eelectron: %g\n",Ebind,Eelec);
	if (!bIonize) {
	  /* Subtract momentum of recoiling photon */
	  /*phi     = 2*M_PI*rando(&seed);
 	    bKHole  = FALSE;  
	    factor  = ephot*438;  
	    dv[XX] -= factor*cos(phi)*sin(theta);
	    dv[YY] -= factor*sin(phi)*sin(theta);
	    dv[ZZ] -= factor*cos(theta);
	  */
	  if (debug)
	    pr_rvec(debug,0,"INELL",dv,DIM);
	}
	break;
      }
      default:
	fatal_error(0,"Ga direct naar de gevangenis. Ga  niet langs start");
      }
      if (bIonize) {
	/* First increase the charge */
	if (ca[i].n < ca[i].z) {
	  md->chargeA[i] += 1.0;
	  md->chargeB[i] += 1.0;
	  ca[i].n++;
	  dq ++;
	  total ++;
	}
	if (debug) {
	  fprintf(debug,"Random-dv[%3d] = %10.3e,%10.3e,%10.3e,"
		  " ephot = %d, Elost=%10.3e\n",
		  i,dv[XX],dv[YY],dv[ZZ],ephot,E_lost);
	}
      }
      /* Now actually add the impulse to the velocities */
      for(m=0; (m<DIM); m++)
	v[i][m] += dv[m];
      if (bKHole) {
	ca[i].k ++;
	fprintf(ion,"  K:%d",i+1);
      }
      else if (bIonize)
	fprintf(ion,"  I:%d",i+1);
    }
    
    /* Now check old event: Loop over k holes! */
    nkhole = ca[i].k;
    for (kk = 0; (kk < nkhole); kk++) 
      if (khole_decay(log,&(ca[i]),v[i],&seed,ir->delta_t,i)) {
	nkdecay ++;
	nkd_tot ++;
	fprintf(ion,"  D:%d",i+1);
      }
    
    if (debug && (ca[i].n > 0))
      dump_ca(debug,&(ca[i]),i,__FILE__,__LINE__);
  }
  where();
  
  fprintf(ion,"\n");
  fprintf(xvg,"%10.5f  %10.3e  %6d  %6d  %6d  %6d\n",
	  t,pt,(int)dq,(int)total,(int)nkdecay,(int)nkd_tot);
  fflush(ion);
  fflush(xvg);
}

