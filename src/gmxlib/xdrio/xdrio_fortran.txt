Documentation for the FORTRAN interface to xdrfile.



NAME MANGLING

Fortran compilers usually add an underscore at the end of global identifiers, 
and sometimes translates function names to all lower-case or all upper-case.
It works great to link with C functions if we take this into account.

By default, the xdrfile.c module assumes your FORTRAN compiler uses lower-case
names, and adds a single underscore at the end of the name. If your compiler
is different, just define the name-mangling macro F77_FUNC when you compile
xdrfile.c. For example, to use upper-case and prepend an underscore:


#define F77_FUNC(name,NAME) _ ## NAME





FUNCTION INTERFACE

All XDRFILE functions are defined as subroutines, with the return code
as a parameter to avoid having to declare all functions you use as integers.

We assume real is 4 bytes, double precision 8 bytes, and integer 4 bytes.

   


OPENING / CLOSING FILES 

xdropen(fid, name, mode)
	     
	     Open an XDR file for IO, return integer file handle.
	     
	     integer		fid	File handle returned. Negative==error.
	     character*N	name	File name
	     character*N	mode	"r" is read, "w" is write, "a" append.
	     

xdrclose(fid)
	     
	     Close an XDR file and release resources.	

	     integer		fid	File handle returned by xdropen()


READING / WRITING DATA

All basic routines are named 'xdr' + 'r' for read or 'w' for write + datatype.
Available datatypes are 'char', 'short', int'. Unsigned versions have a 'u'
prepended, so xdrruint() means reading of unsigned integer variables.



xdrrint(fid, data, ndata, ret)
xdrruint(fid, data, ndata, ret)

	     Read integers (xdrrint), or unsigned integers (xdrruint)

	     integer		fid	File handle returned by xdropen()
	     integer (array)    data    Memory where to put data
	     integer            ndata	Number of elements to read
	     integer		ret	Return code = number of elements read.


xdrwint(fid, data, ndata, ret)
xdrwuint(fid, data, ndata, ret)

	     Write integers (xdrwint), or unsigned integers (xdrwuint)

	     integer		fid	File handle returned by xdropen()
	     integer (array)    data    Memory where data is located
	     integer            ndata	Number of elements to write
	     integer		ret	Returned = number of elements written

	
xdrrchar(fid, data, ndata, ret)
xdrruchar(fid, data, ndata, ret)
xdrwchar(fid, data, ndata, ret)
xdrwuchar(fid, data, ndata, ret)

	     Read/write characters/unsigned characters

	     integer		fid	File handle returned by xdropen()
	     char (array)       data    Memory where data is read/written
	     integer            ndata	Number of elements to read/write
	     integer		ret	Return code = number of elements 
                                        read/written in the routine.


xdrrshort(fid, data, ndata, ret)
xdrrushort(fid, data, ndata, ret)
xdrwshort(fid, data, ndata, ret)
xdrwushort(fid, data, ndata, ret)

	     Read/write short integers/unsigned short integers characters

	     integer		fid	File handle returned by xdropen()
	     short (array)      data    Memory where data is read/written
	     integer            ndata	Number of elements to read/write
	     integer		ret	Return code = number of elements 
                                        read/written in the routine.


xdrrsingle(fid, data, ndata, ret)

	     Read single precision floating-point numbers from file.
             Note that some dialects of FORTRAN use double precision by default
             for REAL variables, so check the size of the variables 
             and call either the single or double precision routine.

	     integer		fid	File handle returned by xdropen()
	     real               data    Memory where to put data.
                                        SINGLE PRECISION FOR THIS ROUTINE!
	     integer            ndata	Number of elements to read
	     integer		ret	Return code = number of elements read
	

xdrwsingle(fid, data, ndata, ret)

	     Write single precision floating-point numbers to file.
             Note that some dialects of FORTRAN use double precision by default
             for REAL variables, so check the size of the variables. 
             and call either the single or double precision routine.

	     integer		fid	File handle returned by xdropen()
	     real               data    Memory where data is read.
                                        SINGLE PRECISION FOR THIS ROUTINE!!
	     integer            ndata	Number of elements to write
	     integer		ret	Return code = number of elements 
                                        written by routine.
	

xdrrdouble(fid, data, ndata, ret)

	     Read double precision floating-point numbers from file.

	     integer		fid	File handle returned by xdropen()
	     double precision   data    Memory where to put data 
                                        DOUBLE PRECISION FOR THIS ROUTINE!
	     integer            ndata	Number of elements to read
	     integer		ret	Return code = number of elements read
	

xdrwdouble(fid, data, ndata, ret)

	     Write double precision floating-point numbers to file.

	     integer		fid	File handle returned by xdropen()
	     double precision   data    Memory where data is read 
                                        DOUBLE PRECISION FOR THIS ROUTINE!
	     integer            ndata	Number of elements to write
	     integer		ret	Return code = number of elements 
                                        written by routine
	

xdrrstring(fid, str, ret)

	     Read string from file and convert to FORTRAN string.

	     integer		fid	File handle returned by xdropen()
	     character*N	str	Fortran string
	     integer		ret	Return code = number of bytes read


xdrwstring(fid, str, ret)

	     Write string to file (and convert it to a C string)

	     integer		fid	File handle returned by xdropen()
	     character*N	str	Fortran string
	     integer		ret	Return code = number of bytes written




xdrropaque(fid, data, ndata, ret)
xdrwopaque(fid, data, ndata, ret)

	     Read/write generic non-specific data

	     integer		fid	File handle returned by xdropen()
	     char (array)       data    Memory where data is read/written
	     integer            ndata	Number of elements to read/write
	     integer		ret	Return code = number of elements 
                                        read/written by routine


xdrccs(fid, data, ncoord, prec, ret)

	     Compress Coordinates in Single precision, write to XDR file.
	     
	     Lossy compression is performed by multiplying the ncoord 
             coordinate triplets by prec, and rounding them to integers.  
	     If prec is negative or zero, the default value 1000.0 is used - 
             this will give you three decimals of guaranteed accuracy.

	     integer		fid	File handle returned by xdropen()
	     real (array)       data    Memory where to read coordinates.
                                        SINGLE PRECISION FOR THIS ROUTINE!
	     integer            ncoord	Number of coordinate triplets to write
	     real		prec    Precision for lossy compression.       
	     integer		ret	Return code = number of coordinate
                                        triplets written.


xdrdcs(fid, data, ncoord, prec, ret)

	     Decompress Coordinates in Single precision from XDR file.
	     
	     Read back ncoord coordinate triplets from a compressed format 
             previously created with xdrccs(). IMPORTANT: You *must* provide 
             enough space in the data array to store all coordinates. If not, 
             the routine will return an error, but since we cannot guarantee 
             file positioning on large (>64bit) files you will have to close,
             reopen, and reread the file to recover.
            
             The best way to avoid this is to store the number of coordinates 
             as an integer just before the compressed coordinate block created
             with xdrccs(). Then you can read the number of coords, allocate 
             memory, and finally read the actual coordinates.

	     integer		fid	File handle returned by xdropen()
	     real (array)       data    Memory where to put coordinates
                                        SINGLE PRECISION FOR THIS ROUTINE!
	     integer            ncoord	Max number of coord. triplets to read
	     real		prec    Precision used in prior compression 
                                        (returned value)    
	     integer		ret	Return code = number of coordinate
                                        triplets read


xdrccd(fid, data, ncoord, prec, ret)

	     Compress Coordinates in Double precision, write to XDR file.
	     
	     Note that double does not give you extra precision since the 
             coordinates are subject to lossy compression.
	     Lossy compression is performed by multiplying the ncoord 
             coordinate triplets by prec, and rounding them to integers.  
	     If prec is negative or zero, the default value 1000.0 is used - 
             this will give you three decimals of guaranteed accuracy.
	     
	     This is just a convenience routine to avoid having to use an
             intermediary single-precision array when your program uses 
             double precision. If you need double precision trajectories
             there is no point in using this type of lossy compression.

	     integer		fid	File handle returned by xdropen()
	     double (array)     data    Memory where to read coordinates 
                                        DOUBLE PRECISION FOR THIS ROUTINE!
	     integer            ncoord	Number of coordinate triplets to write
	     double precision	prec    Precision for lossy compression.       
	     integer		ret	Return code = number of coordinate
                                        triplets written.


xdrdcd(fid, data, ncoord, prec, ret)

	     Decompress Coordinates in Double precision from XDR file.
	     
	     Note that double does not give you extra precision since the 
             coordinates are subject to lossy compression.

	     Read back ncoord coordinate triplets from a compressed format 
             previously created with xdrccs(). IMPORTANT: You must provide 
             enough space in data to store all coordinates. If not, the 
             routine will return an error, but since we cannot guarantee file 
             positioning on large (>64bit) files you will have to close,
             reopen, and reread the file to recover.
            
             The best way to avoid this is to store the number of coordinates 
             as an integer just before the compressed coordinate block created
             with xdrccs(). Then you can read the number of coords, allocate
             memory, and finally read the actual coordinates.

	     integer		fid	File handle returned by xdropen()
	     double (array)     data    Memory where to put coordinates 
                                        DOUBLE PRECISION FOR THIS ROUTINE!
	     integer            ncoord	Max number of coord. triplets to read
	     double precision	prec    Precision used in prior compression 
                                        (returned value)    
	     integer		ret	Return code = number of coordinate
                                        triplets read.





