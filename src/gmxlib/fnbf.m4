/*
 *       $Id$
 *
 *       This source code is part of
 *
 *        G   R   O   M   A   C   S
 *
 * GROningen MAchine for Chemical Simulations
 *
 *            VERSION 2.0
 * 
 * Copyright (c) 1991-1999
 * BIOSON Research Institute, Dept. of Biophysical Chemistry
 * University of Groningen, The Netherlands
 * 
 * Please refer to:
 * GROMACS: A message-passing parallel molecular dynamics implementation
 * H.J.C. Berendsen, D. van der Spoel and R. van Drunen
 * Comp. Phys. Comm. 91, 43-56 (1995)
 *
 * Also check out our WWW page:
 * http://rugmd0.chem.rug.nl/~gmx
 * or e-mail to:
 * gromacs@chem.rug.nl
 *
 * And Hey:
 * GROningen MAchine for Chemical Simulation
 */
 
/********************************************************
 *	fnbf.c IS A GENERATED FILE DO NOT EDIT     	*
 *     		edit fnbf.m4 instead			*
 ********************************************************/
 
static char *SRCID_fnbf_c = "$Id$";
#ifdef USE_THREADS  
#include <pthread.h>  /* must come first! */
#endif
#include <stdio.h>
#include "typedefs.h"
#include "txtdump.h"
#include "smalloc.h"
#include "ns.h"
#include "vec.h"
#include "maths.h"
#include "macros.h"
#include "force.h"
#include "names.h"
#include "main.h"
#include "xvgr.h"
#include "fatal.h"
#include "physics.h"
#include "force.h"
#include "inner.h"
#include "nrnb.h"
#include "smalloc.h"
#if (defined USE_SSE_AND_3DNOW && defined _lnx_ && !defined DOUBLE) 
#include "x86cpu.h"
#endif

#ifdef USE_VECTOR
static real *fbuf=NULL;
#endif	



void do_fnbf(FILE *log,t_commrec *cr,t_forcerec *fr,
	     rvec x[],rvec f[],t_mdatoms *mdatoms,
	     real egnb[],real egcoul[],rvec box_size,
	     t_nrnb *nrnb,real lambda,real *dvdlambda,
	     bool bLR,int eNL)
{
  t_nblist *nlist;
  real     *fshift;
  int      i,i0,i1,nrnb_ind,sz;
  bool     bWater;
#if (defined USE_SSE_AND_3DNOW && defined _lnx_ && !defined DOUBLE)
  static int x86cpu=-1;
#endif
#if (defined VECTORIZE_INVSQRT || defined VECTORIZE_RECIP)
static int buflen=0;
static real *drbuf=NULL;
static real *buf1=NULL;
static real *buf2=NULL;
#endif

#ifdef USE_VECTOR
  if (fbuf == NULL)
    snew(fbuf,mdatoms->nr*3);
#endif
  
#if (defined VECTORIZE_INVSQRT || defined VECTORIZE_RECIP)
  if (buflen==0) {
    buflen=VECTORIZATION_BUFLENGTH;
    snew(drbuf,3*buflen);
    snew(buf1,buflen);
    snew(buf2,buflen);
    fprintf(log,"Using buffers of length %d for innerloop vectorization.\n",buflen);
  }
#endif

#if (defined USE_SSE_AND_3DNOW && defined _lnx_ && !defined DOUBLE)
 if(x86cpu==-1) 
	x86cpu=check_x86cpu(log);
#endif
  if (eNL >= 0) {
    i0 = eNL;
    i1 = i0+1;
  }
  else {
    i0 = 0;
    i1 = eNL_NR;
  }
  if (bLR)
    fshift = fr->fshift_twin[0];
  else
    fshift = fr->fshift[0];

  for(i=i0; (i<i1); i++) {
    if (bLR) 
      nlist  = &(fr->nlist_lr[i]);
    else
      nlist = &(fr->nlist_sr[i]);

    if (nlist->nri > 0) {
      nrnb_ind = nlist->il_code;

#if (defined VECTORIZE_INVSQRT || defined VECTORIZE_RECIP)
      /* make sure buffers can hold the longest neighbourlist */
      if(nlist->solvent==esolWATERWATER)			
	sz = 9*nlist->maxlen;
      else if(nlist->solvent==esolWATER) 
	sz = 3*nlist->maxlen;
      else	
        sz = nlist->maxlen;

      if(sz>buflen) {
	fprintf(log,"Note: Increasing vectorization buffer from %d to %d to make room for\n"
                    "longest neighbourlist. This might hurt cache performance, in which case\n"
                    "you should consider disabling innerloop vectorization.\n\n",buflen,sz+100);
	buflen=(sz+100); /* use some extra size to avoid reallocating next step */
    	srenew(drbuf,3*buflen);
    	srenew(buf1,buflen);
    	srenew(buf2,buflen);
      }	
#endif 	    


/* This is NOT very pretty... Ideally, the calling sequence should change automatically,
 * i.e. be generated by mkinl. Oh well, later... /EL 000826
 */

define(`COMMON_ARGS',`SCAL(nlist->nri),nlist->iinr,nlist->jindex,nlist->jjnr,nlist->`shift',fr->shift_vec[0],fshift,nlist->gid ,x[0],f[0] ifdef(`USE_VECTOR',`,fbuf') ifdef(`USE_THREADS',`,SCAL(cr->threadid),SCAL(cr->nthreads),&(nlist->count),nlist->mtx')')
define(`REC_BUF',`ifdef(`VECTORIZE_RECIP',`,drbuf,buf1 ifdef(`USE_VECTOR',`,buf2')')')
define(`INVSQRT_BUF1',`ifdef(`VECTORIZE_INVSQRT',`,drbuf,buf1 ifdef(`USE_VECTOR',`,buf2')')')
define(`INVSQRT_BUF2',`ifdef(`VECTORIZE_INVSQRT',`ifdef(`USE_VECTOR',`',`,buf2')')')      
define(`LJ_ARGS',`,mdatoms->typeA, SCAL(fr->ntype),fr->nbfp,egnb')
define(`COUL_ARGS',`,mdatoms->chargeA, SCAL(fr->epsfac),egcoul')
define(`SOFTCORE_LJARGS',`,mdatoms->typeA, SCAL(fr->ntype),fr->nbfp')
define(`RF_ARGS',`,SCAL(fr->k_rf)')
define(`LJCTAB_ARGS',`,SCAL(fr->tabscale),fr->coulvdwtab')
define(`COULTAB_ARGS',`,SCAL(fr->tabscale),fr->coultab')
define(`LJTAB_ARGS',`,SCAL(fr->tabscale),fr->vdwtab')
define(`BHTAB_ARGS',`,SCAL(fr->tabscale_exp)')
define(`FREE_ARGS',`,SCAL(lambda),dvdlambda')
define(`FREE_CHARGEB',`,mdatoms->chargeB')
define(`FREE_TYPEB',`,mdatoms->typeB')
define(`SOFTCORE_ARGS',`,SCAL(fr->sc_alpha),SCAL(fr->sc_sigma6)')
define(`SOLMN_ARGS',`,nlist->nsatoms')
      switch (nrnb_ind) { 
	case eNR_INL0100:
	  FUNC(inl0100)(COMMON_ARGS REC_BUF LJ_ARGS);
	break;
        case eNR_INL0110:
          FUNC(inl0110)(COMMON_ARGS REC_BUF LJ_ARGS SOLMN_ARGS);
        break;
	case eNR_INL0200: 
	  FUNC(inl0200)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS);
	break;
	case eNR_INL0210:
          FUNC(inl0210)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS SOLMN_ARGS);
        break;
	case eNR_INL0300:
	  FUNC(inl0300)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS LJTAB_ARGS);
	break;
	case eNR_INL0310:
          FUNC(inl0310)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS LJTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL0301:
	  FUNC(inl0301)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS LJTAB_ARGS FREE_ARGS FREE_TYPEB);
	break;
	case eNR_INL0302:
	  FUNC(inl0302)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS LJTAB_ARGS FREE_ARGS FREE_TYPEB SOFTCORE_ARGS);
	break;
	case eNR_INL0400:
	  FUNC(inl0400)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS LJTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL0410:
          FUNC(inl0410)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS LJTAB_ARGS BHTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL0401:
	  FUNC(inl0401)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS LJTAB_ARGS BHTAB_ARGS FREE_ARGS FREE_TYPEB);
	break;
	case eNR_INL0402:
	  FUNC(inl0402)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 LJ_ARGS LJTAB_ARGS BHTAB_ARGS FREE_ARGS FREE_TYPEB SOFTCORE_ARGS);
	break;
	case eNR_INL1000:
	  FUNC(inl1000)(COMMON_ARGS INVSQRT_BUF1 COUL_ARGS);
	break;
	case eNR_INL1010:
	  FUNC(inl1010)(COMMON_ARGS INVSQRT_BUF1 COUL_ARGS SOLMN_ARGS);
 	break;
	case eNR_INL1020:
	  FUNC(inl1020)(COMMON_ARGS INVSQRT_BUF1 COUL_ARGS);
	break;
	case eNR_INL1030:
	  FUNC(inl1030)(COMMON_ARGS INVSQRT_BUF1 COUL_ARGS);
	break;
	case eNR_INL1100:
	  FUNC(inl1100)(COMMON_ARGS INVSQRT_BUF1 COUL_ARGS LJ_ARGS);
	break;
	case eNR_INL1110:
	  FUNC(inl1110)(COMMON_ARGS INVSQRT_BUF1 COUL_ARGS LJ_ARGS SOLMN_ARGS);
	break;
	case eNR_INL1120:
	  FUNC(inl1120)(COMMON_ARGS INVSQRT_BUF1 COUL_ARGS LJ_ARGS);
	break;
	case eNR_INL1130:
	  FUNC(inl1130)(COMMON_ARGS INVSQRT_BUF1 COUL_ARGS LJ_ARGS);
	break;
	case eNR_INL1200:
	  FUNC(inl1200)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS);
	break;
	case eNR_INL1210:
	  FUNC(inl1210)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS SOLMN_ARGS);
	break;
	case eNR_INL1220:
	  FUNC(inl1220)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS);
	break;
	case eNR_INL1230:
	  FUNC(inl1230)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS);
	break;
	case eNR_INL1300:
	  FUNC(inl1300)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJTAB_ARGS);
	break;
	case eNR_INL1310:
	  FUNC(inl1310)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL1320:
	  FUNC(inl1320)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJTAB_ARGS);
	break;
	case eNR_INL1330:
	  FUNC(inl1330)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJTAB_ARGS);
	break;
	case eNR_INL1400:
	  FUNC(inl1400)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL1410:
	  FUNC(inl1410)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJTAB_ARGS BHTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL1420:
	  FUNC(inl1420)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL1430:
	  FUNC(inl1430)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL2000:
	  FUNC(inl2000)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS);
	break;
	case eNR_INL2010:
	  FUNC(inl2010)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS SOLMN_ARGS);
	break;
	case eNR_INL2020:
	  FUNC(inl2020)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS);
	break;
	case eNR_INL2030:
	  FUNC(inl2030)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS);
	break;
	case eNR_INL2100:
	  FUNC(inl2100)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS);
	break;
	case eNR_INL2110:
	  FUNC(inl2110)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS SOLMN_ARGS);
	break;
	case eNR_INL2120:
	  FUNC(inl2120)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS);
	break;
	case eNR_INL2130:
	  FUNC(inl2130)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS);
	break;
	case eNR_INL2200:
	  FUNC(inl2200)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS);
	break;
	case eNR_INL2210:
	  FUNC(inl2210)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS SOLMN_ARGS);
	break;
	case eNR_INL2220:
	  FUNC(inl2220)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS);
	break;
	case eNR_INL2230:
	  FUNC(inl2230)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS);
	break;
	case eNR_INL2300:
	  FUNC(inl2300)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS LJTAB_ARGS);
	break;
	case eNR_INL2310:
	  FUNC(inl2310)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS LJTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL2320:
	  FUNC(inl2320)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS LJTAB_ARGS);
	break;
	case eNR_INL2330:
	  FUNC(inl2330)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS LJTAB_ARGS);
	break;
	case eNR_INL2400:
	  FUNC(inl2400)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS LJTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL2410:
	  FUNC(inl2410)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS LJTAB_ARGS BHTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL2420:
	  FUNC(inl2420)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS LJTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL2430:
	  FUNC(inl2430)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS RF_ARGS LJ_ARGS LJTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL3000:
	  FUNC(inl3000)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3001:
	  FUNC(inl3001)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS COULTAB_ARGS FREE_ARGS FREE_CHARGEB);
	break;
	case eNR_INL3002:
	  FUNC(inl3002)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS SOFTCORE_LJARGS COULTAB_ARGS FREE_ARGS FREE_CHARGEB FREE_TYPEB SOFTCORE_ARGS);
	break;
	case eNR_INL3010:
	  FUNC(inl3010)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS COULTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL3020:
	  FUNC(inl3020)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3030:
	  FUNC(inl3030)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3100:
	  FUNC(inl3100)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3110:
	  FUNC(inl3110)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS COULTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL3120:
	  FUNC(inl3120)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3130:
	  FUNC(inl3130)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3200:
	  FUNC(inl3200)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3210:
	  FUNC(inl3210)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS COULTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL3220:
	  FUNC(inl3220)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3230:
	  FUNC(inl3230)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS COULTAB_ARGS);
	break;
	case eNR_INL3300:
	  FUNC(inl3300)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS);
	break;
	case eNR_INL3301:
	  FUNC(inl3301)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS FREE_ARGS FREE_CHARGEB FREE_TYPEB);
	break;
	case eNR_INL3302:
	  FUNC(inl3302)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS FREE_ARGS FREE_CHARGEB FREE_TYPEB SOFTCORE_ARGS);
	break;
	case eNR_INL3310:
	  FUNC(inl3310)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL3320:
	  FUNC(inl3320)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS);
	break;
	case eNR_INL3330:
	  FUNC(inl3330)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS);
	break;
	case eNR_INL3400:
	  FUNC(inl3400)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL3401:
	  FUNC(inl3401)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS BHTAB_ARGS FREE_ARGS FREE_CHARGEB FREE_TYPEB);
	break;
	case eNR_INL3402:
	  FUNC(inl3402)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS BHTAB_ARGS FREE_ARGS FREE_CHARGEB FREE_TYPEB SOFTCORE_ARGS);
	break;
	case eNR_INL3410:
	  FUNC(inl3410)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS BHTAB_ARGS SOLMN_ARGS);
	break;
	case eNR_INL3420:
	  FUNC(inl3420)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INL3430:
	  FUNC(inl3430)(COMMON_ARGS INVSQRT_BUF1 INVSQRT_BUF2 COUL_ARGS LJ_ARGS LJCTAB_ARGS BHTAB_ARGS);
	break;
	case eNR_INLNONE:
	fatal_error(0,"nrnb_ind is \"NONE\", bad selection made in ns.c");
      default:
	fatal_error(0,"No function corresponding to %s in %s `line' %d",
		    nrnb_str(nrnb_ind),__FILE__,__LINE__);
      }
      /* Mega flops accounting */
      if (nlist->solvent==esolWATER) 
        inc_nrnb(nrnb,eNR_INL_IATOM,3*nlist->nri);
      else if(nlist->solvent==esolWATERWATER)
        inc_nrnb(nrnb,eNR_INL_IATOM,9*nlist->nri);
      else if(nlist->solvent==esolMNO)
	/* should be different for vdwc, coul and vdw loops */
        inc_nrnb(nrnb,eNR_INL_IATOM,fr->nMNOav[0]*nlist->nri);
      else		
        inc_nrnb(nrnb,eNR_INL_IATOM,nlist->nri);	
      	
      if(nlist->solvent==esolMNO)
	/* should be different for vdwc, coul and vdw loops */ 
        inc_nrnb(nrnb,nrnb_ind,fr->nMNOav[0]*nlist->nrj);
      else		
        inc_nrnb(nrnb,nrnb_ind,nlist->nrj);
    }
  }
}

static real dist2(rvec x,rvec y)
{
  rvec dx;
  
  rvec_sub(x,y,dx);
  
  return iprod(dx,dx);
}

static real *mk_14parm(int ntype,int nbonds,t_iatom iatoms[],
		       t_iparams *iparams,int type[])
{
  /* This routine fills a matrix with interaction parameters for
   * 1-4 interaction. It is assumed that these are atomtype dependent
   * only... (but this is checked for...)
   */
  real *nbfp,c6sav,c12sav;
  int  i,ip,ti,tj;
  
  snew(nbfp,2*ntype*ntype);
  for(i=0; (i<nbonds); i+= 3) {
    ip = iatoms[i];
    ti = type[iatoms[i+1]];
    tj = type[iatoms[i+2]];
    c6sav  = C6(nbfp,ntype,ti,tj);
    c12sav = C12(nbfp,ntype,ti,tj);
    C6(nbfp,ntype,ti,tj)  = iparams[ip].lj14.c6A;
    C12(nbfp,ntype,ti,tj) = iparams[ip].lj14.c12A;
    if ((c6sav != 0) || (c12sav != 0)) {
      if ((c6sav  !=  C6(nbfp,ntype,ti,tj)) || 
	  (c12sav != C12(nbfp,ntype,ti,tj))) {
	fatal_error(0,"Force field inconsistency: 1-4 interaction parameters "
		    "for atoms %d-%d not the same as for other atoms "
		    "with the same atom type",iatoms[i+1],iatoms[i+2]);
      }
    }
  }
	


  return nbfp;
}



real do_14(int nbonds,t_iatom iatoms[],t_iparams *iparams,
	   rvec x[],rvec f[],t_forcerec *fr,t_graph *g,
	   matrix box,real lambda,real *dvdlambda,
	   t_mdatoms *md,int ngrp,real egnb[],real egcoul[])
{
  static    real *nbfp14=NULL;
  static    bool bWarn=FALSE;
  real      eps;
  real      r2,rtab2;
  rvec      fi,fj;
  int       ai,aj,itype;
  t_iatom   *ia0,*iatom;
  int       gid,shift14;
  int       j_index[] = { 0, 1 };
  int       i1=1,i3=3,si,i0;
  ivec      dt;
#ifdef USEVECTOR
  if (fbuf == NULL)
    snew(fbuf,md->nr*3);
#endif  



  if (nbfp14 == NULL) {
    nbfp14 = mk_14parm(fr->ntype,nbonds,iatoms,iparams,md->typeA);
    if (debug)
      pr_rvec(debug,0,"nbfp14",nbfp14,sqr(fr->ntype));
  }
  shift14 = CENTRAL;
  
  /* Reaction field stuff */  
  eps    = fr->epsfac*fr->fudgeQQ;
  
  rtab2 = sqr(fr->rtab);
    
  ia0=iatoms;

  for(iatom=ia0; (iatom<ia0+nbonds); iatom+=3) {
    itype = iatom[0];
    ai    = iatom[1];
    aj    = iatom[2];

   
    r2    = distance2(x[ai],x[aj]);
    copy_rvec(f[ai],fi);
    copy_rvec(f[aj],fj);

    
/* We do not check if the neighbourlists fit in the buffer here, since I cant imagine
 * a particle having so many 1-4 interactions :-) /EL 
 */

    if (r2 >= rtab2) {
      if (!bWarn) {
        fprintf(stderr,"Warning: 1-4 interaction at distance larger than %g\n",
	        rtab2);
	fprintf(stderr,"These are ignored for the rest of the simulation\n"
	        "turn on -debug for more information\n");
	bWarn = TRUE;
      }
      if (debug) 
        fprintf(debug,"%8f %8f %8f\n%8f %8f %8f\n1-4 (%d,%d) interaction not within cut-off! r=%g. Ignored",
	      	x[ai][XX],x[ai][YY],x[ai][ZZ],
	      x[aj][XX],x[aj][YY],x[aj][ZZ],
	      (int)ai+1,(int)aj+1,sqrt(r2));
    }
    else {
    gid  = GID(md->cENER[ai],md->cENER[aj],ngrp);
#ifdef DEBUG
    fprintf(debug,"LJ14: grp-i=%2d, grp-j=%2d, ngrp=%2d, GID=%d\n",
	    md->cENER[ai],md->cENER[aj],ngrp,gid);
#endif

    if (md->bPerturbed[ai] || md->bPerturbed[aj]) {
      int  tiA,tiB,tjA,tjB;
      real nbfp[18];
      
      /* Save old types */
      tiA = md->typeA[ai];
      tiB = md->typeB[ai];
      tjA = md->typeA[aj];
      tjB = md->typeB[aj];
      md->typeA[ai] = 0;
      md->typeB[ai] = 1;
      md->typeA[aj] = 2;
      md->typeB[aj] = 3;
      
      /* Set nonbonded params */
      C6(nbfp,4,0,2)  = iparams[itype].lj14.c6A;
      C6(nbfp,4,1,2)  = iparams[itype].lj14.c6B;
      C12(nbfp,4,0,2) = iparams[itype].lj14.c12A;
      C12(nbfp,4,1,2) = iparams[itype].lj14.c12B;
      

define(`COMMON_ARGS',`SCAL(i1),&ai,j_index,&aj,&shift14,fr->shift_vec[0],fr->fshift[0],&gid ,x[0],f[0] ifdef(`USE_VECTOR',`,fbuf')')
define(`COUL_ARGS',`,md->chargeA,SCAL(eps),egcoul')
define(`LJCTAB_ARGS',`,SCAL(fr->tabscale),fr->coulvdw14tab')
define(`LJ_ARGS',`,md->typeA,SCAL(fr->ntype),nbfp14,egnb')


      if(fr->sc_alpha>0)
#if (defined VECTORIZE_INVSQRT || defined USE_THREADS)
	FUNC(inl3302n)(COMMON_ARGS /* special version without some optimizations */
#else	
	 FUNC(inl3302)(COMMON_ARGS /* use normal innerloop */
#endif
                       ,md->chargeA,SCAL(eps),egcoul
	               ,md->typeA,SCAL(i3),nbfp,egnb,
                       SCAL(fr->tabscale),fr->coulvdw14tab,
	               SCAL(lambda),dvdlambda,md->chargeB,md->typeB,SCAL(fr->sc_alpha),SCAL(fr->sc_sigma6));
      else
#if (defined VECTORIZE_INVSQRT || defined USE_THREADS)
	FUNC(inl3301n)(COMMON_ARGS /* special version without some optimizations */
#else	
	 FUNC(inl3301)(COMMON_ARGS /* use normal innerloop */
#endif
                       ,md->chargeA,SCAL(eps),egcoul
	               ,md->typeA,SCAL(i3),nbfp,egnb,
                       SCAL(fr->tabscale),fr->coulvdw14tab,
	               SCAL(lambda),dvdlambda,md->chargeB,md->typeB);
		 
      /* Restore old types */
      md->typeA[ai] = tiA;
      md->typeB[ai] = tiB;
      md->typeA[aj] = tjA;
      md->typeB[aj] = tjB;
    }
    else 
#if (defined VECTORIZE_INVSQRT || defined USE_THREADS)
	FUNC(inl3300n)(COMMON_ARGS /* special version without some optimizations */
#else	
 	 FUNC(inl3300)(COMMON_ARGS  /* use normal innerloop */
#endif
                     ,md->chargeA,SCAL(eps),egcoul,md->typeA,SCAL(fr->ntype),
		     nbfp14,egnb,SCAL(fr->tabscale),fr->coulvdw14tab);

    /* Now determine the 1-4 force in order to add it to the fshift array 
     * Actually we are first computing minus the force.
     */

    rvec_sub(f[ai],fi,fi);
    /*rvec_sub(f[aj],fj,fj);  */

    ivec_sub(SHIFT_IVEC(g,ai),SHIFT_IVEC(g,aj),dt);    
    si=IVEC2IS(dt);	

    rvec_inc(fr->fshift[si],fi);
    rvec_dec(fr->fshift[CENTRAL],fi);
  }	
  }
  return 0.0;
}

