/*
 *
 *                This source code is part of
 *
 *                 G   R   O   M   A   C   S
 *
 *          GROningen MAchine for Chemical Simulations
 *
 * Written by David van der Spoel, Erik Lindahl, Berk Hess, and others.
 * Copyright (c) 1991-2000, University of Groningen, The Netherlands.
 * Copyright (c) 2001-2009, The GROMACS development team,
 * check out http://www.gromacs.org for more information.

 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * If you want to redistribute modifications, please consider that
 * scientific software is very special. Version control is crucial -
 * bugs must be traceable. We will be happy to consider code for
 * inclusion in the official distribution, but derived work must not
 * be called official GROMACS. Details are found in the README & COPYING
 * files - if they are missing, get the official version at www.gromacs.org.
 *
 * To help us fund GROMACS development, we humbly ask that you cite
 * the papers on the package - you can find them in the top README file.
 *
 * For more info, check our website at http://www.gromacs.org
 */
/*! \internal \file
 * \brief
 * Implementation of gmx::SelectionCollection.
 *
 * \author Teemu Murtola <teemu.murtola@cbr.su.se>
 */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <cassert>

#include <smalloc.h>
#include <statutil.h>
#include <string2.h>
#include <xvgr.h>

#include "poscalc.h"
#include "selmethod.h"

#include "gromacs/fatalerror/fatalerror.h"
#include "gromacs/selection/selectioncollection.h"
#include "gromacs/selection/selection.h"

#include "mempool.h"
#include "scanner.h"
#include "selectioncollection-impl.h"
#include "selelem.h"
#include "selmethod.h"
#include "symrec.h"

/* In parser.y */
/*! \brief
 * Parser function generated by Bison.
 */
int
_gmx_sel_yybparse(void *scanner);

namespace gmx
{

/********************************************************************
 * SelectionCollection::Impl
 */

SelectionCollection::Impl::Impl(gmx_ana_poscalc_coll_t *pcc)
    : _grps(NULL)
{
    _sc.rpost     = NULL;
    _sc.spost     = NULL;
    _sc.bMaskOnly = FALSE;
    _sc.bVelocities = FALSE;
    _sc.bForces   = FALSE;
    _sc.bDebugCompile = FALSE;
    _sc.root      = NULL;
    _sc.nvars     = 0;
    _sc.varstrs   = NULL;
    _sc.top       = NULL;
    gmx_ana_index_clear(&_sc.gall);
    _sc.pcc       = pcc;
    _sc.mempool   = NULL;
    _sc.symtab    = NULL;
}

SelectionCollection::Impl::~Impl()
{
    _gmx_selelem_free_chain(_sc.root);
    SelectionList::const_iterator isel;
    for (isel = _sc.sel.begin(); isel != _sc.sel.end(); ++isel)
    {
        delete *isel;
    }
    for (int i = 0; i < _sc.nvars; ++i)
    {
        sfree(_sc.varstrs[i]);
    }
    sfree(_sc.varstrs);
    gmx_ana_index_deinit(&_sc.gall);
    if (_sc.mempool)
    {
        _gmx_sel_mempool_destroy(_sc.mempool);
    }
    clearSymbolTable();
}

void
SelectionCollection::Impl::clearSymbolTable()
{
    if (_sc.symtab)
    {
        _gmx_sel_symtab_free(_sc.symtab);
        _sc.symtab = NULL;
    }
}

/*! \brief
 * Internal helper function used by gmx_ana_selcollection_parse_*() to do the actual work.
 *
 * \param[in]     maxnr   Maximum number of selections to parse
 *   (if -1, parse as many as provided by the user).
 * \param[in,out] scanner Scanner data structure.
 * \returns       0 on success, -1 on error.
 */
int
SelectionCollection::Impl::runParser(yyscan_t scanner, int maxnr,
                                     std::vector<Selection *> *output)
{
    gmx_ana_selcollection_t *sc = &_sc;
    assert(sc == _gmx_sel_lexer_selcollection(scanner));

    int oldCount = sc->sel.size();
    int bOk = !_gmx_sel_yybparse(scanner);
    _gmx_sel_free_lexer(scanner);
    int nr = sc->sel.size() - oldCount;
    if (maxnr > 0 && nr != maxnr)
    {
        return eeInvalidInput;
    }

    if (bOk)
    {
        SelectionList::const_iterator i;
        for (i = _sc.sel.begin() + oldCount; i != _sc.sel.end(); ++i)
        {
            output->push_back(*i);
        }
    }

    return bOk ? 0 : eeInvalidInput;
}


/********************************************************************
 * SelectionCollection
 */

SelectionCollection::SelectionCollection(gmx_ana_poscalc_coll_t *pcc)
    : _impl(new Impl(pcc))
{
}

SelectionCollection::~SelectionCollection()
{
    delete _impl;
}

int
SelectionCollection::init()
{
    _gmx_sel_symtab_create(&_impl->_sc.symtab);
    gmx_ana_selmethod_register_defaults(_impl->_sc.symtab);
    return 0;
}

/*!
 * \param[out] scp Pointer to a newly allocated empty selection collection.
 * \param[in]  pcc Position calculation data structure to use for selection
 *   position evaluation.
 * \returns    0 on success.
 */
int
SelectionCollection::create(SelectionCollection **scp,
                            gmx_ana_poscalc_coll_t *pcc)
{
    SelectionCollection *sc = new SelectionCollection(pcc);

    int rc = sc->init();
    if (rc != 0)
    {
        *scp = NULL;
        delete sc;
        return rc;
    }
    *scp = sc;
    return 0;
}

/*!
 * \param[in]     type      Default selection reference position type
 *   (one of the strings acceptable for gmx_ana_poscalc_type_from_enum()).
 *
 * Should be called before calling gmx_ana_selcollection_requires_top() or
 * gmx_ana_selcollection_parse_*().
 */
void
SelectionCollection::setReferencePosType(const char *type)
{
    assert(type != NULL);
    _impl->_sc.rpost = type;
}

/*!
 * \param[in]     type      Default selection output position type
 *   (one of the strings acceptable for gmx_ana_poslcalc_type_from_enum()).
 *
 * If \p type is NULL, the default type is not modified.
 * Should be called before calling gmx_ana_selcollection_requires_top() or
 * gmx_ana_selcollection_parse_*().
 */
void
SelectionCollection::setOutputPosType(const char *type)
{
    assert(type != NULL);
    _impl->_sc.spost = type;
}

/*!
 * \param[in]     bMaskOnly If TRUE, the output positions are initialized
 *   using \ref POS_MASKONLY.
 */
void
SelectionCollection::setMaskOnly(bool bMaskOnly)
{
    _impl->_sc.bMaskOnly = bMaskOnly;
}

/*!
 * \param[in]     bVelOut   If TRUE, selections will also evaluate
 *      velocities.
 */
void
SelectionCollection::setVelocityOutput(bool bVelOut)
{
    _impl->_sc.bVelocities = bVelOut;
}

/*!
 * \param[in]     bForceOut If TRUE, selections will also evaluate
 *      forces.
 */
void
SelectionCollection::setForceOutput(bool bForceOut)
{
    _impl->_sc.bForces = bForceOut;
}

/*!
 * \param[in]     bDebug If TRUE, later call to gmx_ana_selcollection_compile()
 *     will print out intermediate selection trees.
 */
void
SelectionCollection::setCompileDebug(bool bDebug)
{
    _impl->_sc.bDebugCompile = bDebug;
}

/*!
 * \param[in]     top       Topology data.
 * \param[in]     natoms    Number of atoms. If <=0, the number of atoms in the
 *   topology is used.
 * \retval  0 on success.
 * \retval  eeInvalidValue if \p top is NULL and \p natoms <= 0.
 *
 * The topology is also set for the position calculation collection
 * associated with \p sc.
 *
 * \p natoms determines the largest atom index that can be selected by the
 * selection: even if the topology contains more atoms, they will not be
 * selected.
 */
int
SelectionCollection::setTopology(t_topology *top, int natoms)
{
    gmx_ana_selcollection_t *sc = &_impl->_sc;
    gmx_ana_poscalc_coll_set_topology(sc->pcc, top);
    sc->top = top;

    /* Get the number of atoms from the topology if it is not given */
    if (natoms <= 0)
    {
        if (sc->top != 0)
        {
            GMX_ERROR(eeInvalidValue,
                      "Selections need either the topology or the number of atoms");
        }
        natoms = sc->top->atoms.nr;
    }
    gmx_ana_index_init_simple(&sc->gall, natoms, NULL);
    return 0;
}

/*!
 * \returns True if any selection in the collection requires topology information.
 *
 * Before gmx_ana_selcollection_parse_*(), the return value is based just on
 * the position types set.
 * After gmx_ana_selcollection_parse_*(), the return value also takes into account the
 * selection keywords used.
 */
bool
SelectionCollection::requiresTopology() const
{
    gmx_ana_selcollection_t *sc = &_impl->_sc;
    t_selelem   *sel;
    e_poscalc_t  type;
    int          flags;
    int          rc;

    if (sc->rpost)
    {
        flags = 0;
        rc = gmx_ana_poscalc_type_from_enum(sc->rpost, &type, &flags);
        if (rc == 0 && type != POS_ATOM)
        {
            return TRUE;
        }
    }
    if (sc->spost)
    {
        flags = 0;
        rc = gmx_ana_poscalc_type_from_enum(sc->spost, &type, &flags);
        if (rc == 0 && type != POS_ATOM)
        {
            return TRUE;
        }
    }

    sel = sc->root;
    while (sel)
    {
        if (_gmx_selelem_requires_top(sel))
        {
            return TRUE;
        }
        sel = sel->next;
    }
    return FALSE;
}

/*!
 * \param[in]     nr    Number of selections to parse
 *   (if -1, parse as many as provided by the user).
 * \param[in]     bInteractive Whether the parser should behave interactively.
 * \returns       0 on success, -1 on error.
 */
int
SelectionCollection::parseFromStdin(int nr, bool bInteractive,
                                    std::vector<Selection *> *output)
{
    yyscan_t scanner;
    int      rc;

    rc = _gmx_sel_init_lexer(&scanner, &_impl->_sc, bInteractive, nr, _impl->_grps);
    if (rc != 0)
    {
        return rc;
    }
    /* We don't set the lexer input here, which causes it to use a special
     * internal implementation for reading from stdin. */
    return _impl->runParser(scanner, nr, output);
}

/*!
 * \param[in]     fnm   Name of the file to parse selections from.
 * \returns       0 on success, -1 on error.
 */
int
SelectionCollection::parseFromFile(const std::string &fnm,
                                   std::vector<Selection *> *output)
{
    yyscan_t scanner;
    FILE *fp;
    int   rc;

    rc = _gmx_sel_init_lexer(&scanner, &_impl->_sc, FALSE, -1, _impl->_grps);
    if (rc != 0)
    {
        return rc;
    }
    fp = ffopen(fnm.c_str(), "r");
    _gmx_sel_set_lex_input_file(scanner, fp);
    rc = _impl->runParser(scanner, -1, output);
    ffclose(fp);
    return rc;
}

/*!
 * \param[in]     str   String to parse selections from.
 * \returns       0 on success, -1 on error.
 */
int
SelectionCollection::parseFromString(const std::string &str,
                                     std::vector<Selection *> *output)
{
    yyscan_t scanner;
    int      rc;

    rc = _gmx_sel_init_lexer(&scanner, &_impl->_sc, FALSE, -1, _impl->_grps);
    if (rc != 0)
    {
        return rc;
    }
    _gmx_sel_set_lex_input_str(scanner, str.c_str());
    return _impl->runParser(scanner, -1, output);
}

int
SelectionCollection::compile()
{
    return gmx_ana_selcollection_compile(this);
}

int
SelectionCollection::evaluate(t_trxframe *fr, t_pbc *pbc)
{
    return gmx_ana_selcollection_evaluate(&_impl->_sc, fr, pbc);
}

int
SelectionCollection::evaluateFinal(int nframes)
{
    return gmx_ana_selcollection_evaluate_fin(&_impl->_sc, nframes);
}

/*!
 * \param[in] fp      File handle to receive the output.
 * \param[in] bValues If TRUE, the evaluated values of selection elements
 *   are printed as well.
 */
void
SelectionCollection::printTree(FILE *fp, bool bValues) const
{
    t_selelem *sel;

    sel = _impl->_sc.root;
    while (sel)
    {
        _gmx_selelem_print_tree(fp, sel, bValues, 0);
        sel = sel->next;
    }
}

/*!
 * \param[in] out  Output file.
 * \param[in] oenv Output options structure.
 */
void
SelectionCollection::printXvgrInfo(FILE *out, output_env_t oenv) const
{
    int  i;

    if (output_env_get_xvg_format(oenv) != exvgNONE)
    {
        gmx_ana_selcollection_t *sc = &_impl->_sc;
        fprintf(out, "# Selections:\n");
        for (i = 0; i < sc->nvars; ++i)
        {
            fprintf(out, "#   %s\n", sc->varstrs[i]);
        }
        for (i = 0; i < (int)sc->sel.size(); ++i)
        {
            fprintf(out, "#   %s\n", sc->sel[i]->_sel.selstr);
        }
        fprintf(out, "#\n");
    }
}

} // namespace gmx
