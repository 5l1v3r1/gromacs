% Save file as: NEWARRAY.STY           Source: FILESERV@SHSU.BITNET  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iffalse
                  newarray.sty
                  %%%%%%%%%%
 This is an extension of F. Mittelbach's array.sty. It adds two essentially
 independent features, the \newcolumn system, whereby users can easily add
 their own letters to LaTeX's standard list of column specifiers (`c', `p',
 etc.), and implicit \left \right delimiters arround an array or tabular.
 Also the \extracolsep command works with this style.

 You must have Mittelbach's array.sty to use this style option.

                   David Carlisle
                   carlisle@uk.ac.man.cs
                   19 July 1991
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% If you have Mittelbach's doc.sty, this file may be formatted with a
% command like:    latex newarray.sty
% (You do not need doc.sty to {\em use} this style.)
%
% To create a faster loading .sty file, copy this file to newarray.doc
% Then remove all the lines beginning with a `%' from the .sty file. This
% may be done with docstrip.tex, or your text editor. The following two
% lines may also be deleted from the .sty file.
\ifcat a\noexpand @\let\next\relax\else\def\next{%
    \documentstyle[newarray,doc]{article}\MakePercentIgnore}\fi\next
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \textwidth=365pt   ^^A Allow macrocode text with 75 columns.
% \CodelineIndex     ^^A Code lines numbered.
% \DisableCrossrefs  ^^A No Cross references.
%
% \title{newarray.sty}
% \author{D. P. Carlisle}
% \date{19 July 1991}
% \begin{document}
% \maketitle
% \begin{abstract}
% This is an extension of F. Mittelbach's {\tt array.sty}. It adds two
% essentially independent features, the \verb|\newcolumn| system, whereby
% users can easily add their own letters to \LaTeX's standard list of
% column specifiers (`c', `p', etc.), and implicit \verb|\left|
% \verb|\right| delimiters arround an {\tt array} or {\tt tabular}. Also
% the \verb|\extracolsep| command works with this style.
%
% You must have Mittelbach's {\tt array.sty} to use this style option, but
% it is not necessary to list {\tt array} in the style options of the
% \verb|\documentstyle| command, as {\tt newarray.sty} explicitly inputs
% {\tt array.sty}.
% \end{abstract}
%
% \section{Introduction}
%
% Mittelbach's {\tt array.sty} is a re-implementation of the {\tt array}
% and {\tt tabular} environments. For the user one of the main advantages
% over the standard environments is the ability to specify declarations to
% be applied to each item in a specified column. These declarations are
% specified in the arguments of two new tokens allowed in the preamble,
% {\tt<} and {\tt>}.  Examples given in {\tt array.doc} include
% \verb|>{\bf}c|, to specify a bold face centred column, and
% \verb|>{$}c<{$}|, for a column which will give centred math-mode in a
% {\tt tabular} and centred LR-mode in an {\tt array}. The final example in
% {\tt array.doc} is for a column of numbers aligned on a decimal point.
% \verb|>{\centerdots}c<{\endcenterdots}|.
% The macros \verb|\centerdots| and \verb|\endcenterdots| may be defined
% by:
%       \begin{verbatim}
% \def\coldot{.}% Or if you prefer, \def\coldot{\cdot}
% {\catcode`\.=\active\gdef.{$\egroup\setbox2=\hbox\bgroup$\coldot}}
% \def\centerdots{%
%    \setbox2=\hbox{$\phantom\coldot$}%
%    \setbox0=\hbox\bgroup\mathcode`\.="8000 $}
% \def\endcenterdots{$\egroup
%    \ifdim \wd0>\wd2 \setbox2=\hbox to\wd0{\unhbox2\hfill}\else
%      \setbox0=\hbox to\wd2{\hfill\unhbox0}\fi
%    \box0\box2}
% \end{verbatim}
% These definitions are slightly modified from the versions given in {\tt
% array.doc}, with this version you can have blank entries, or entries such
% as~.5\,. You may say that it is bad style to write~.5 rather tan 0.5, but
% \LaTeX\ should still do something sensible with such an entry. This is
% the usual problem of \TeX\ looking ahead (for \verb|\omit| in this case)
% and messing up a catcode change. This version also does not depend on
% \verb|\box2| being void before the start of the environment.
%
% \subsection{Defining new column specifiers}
%
% Whilst it is handy to be able to type\\
% \verb|>{|\meta{some declarations}\verb|}{c}<{|\meta{some more
% declarations}\verb|}|\\
% if you have a one-off column in a table, it is rather inconvenient
% if you often use columns of this form. {\tt newarray.sty} allows you
% to define a new column specifier, say {\tt x}, which will expand to
% the primitives of Mittelbach's {\tt array.sty}. Thus we may define\\
% \verb|\newcolumn{x}{>{|\meta{some declarations}\verb|}{c}<{|\meta{some
% more declarations}\verb|}}|\\
% One can then use the {\tt x} column specifier in the preamble
% arguments of all {\tt array} or {\tt tabular} environments in which
% you want columns of this form.
%
% It is common  to need math-mode and LR-mode columns in the same
% alignment. If we define:
% \begin{verbatim}
%\newcolumn{C}{>{$}c<{$}}  \newcolumn{L}{>{$}l<{$}}  \newcolumn{R}{>{$}r<{$}}
% \end{verbatim}
% Then we can use {\tt C} to get centred LR-mode in an {\tt array}, or
% centred math-mode in a {\tt tabular}.
%
% The example given above for `centred decimal points' could be
% assigned to a {\tt d} specifier with the following command.\\
% \verb|\newcolumn{d}{>{\centerdots}c<{\endcenterdots}}|
%
% The above solution always centres the dot in the
% column. This does not look too good if the column consists of large
% numbers, but to only a few decimal places. An alternative definition
% of a {\tt d} column is \\
% \verb|\newcolumn{d}[1]{>{\rightdots{#1}}r<{\endrightdots}}|\\
% where the appropriate macros in this case are:
% \begin{verbatim}
% \def\coldot{.}% Or if you prefer, \def\coldot{\cdot}
% {\catcode`\.=\active
%   \gdef.{$\egroup\setbox2=\hbox to \dimen0 \bgroup$\coldot}}
% \def\rightdots#1{%
%   \setbox0=\hbox{$1$}\dimen0=#1\wd0
%   \setbox0=\hbox{$\coldot$}\advance\dimen0 \wd0
%   \setbox2=\hbox to \dimen0 {}%
%   \setbox0=\hbox\bgroup\mathcode`\.="8000 $}
% \def\endrightdots{$\hfil\egroup\box0\box2}
% \end{verbatim}
% Note that \verb|\newcolumn| takes the same optional argument as
% \verb|\newcommand| which declares the number of arguments of the column
% specifier being defined. Now we can specify \verb|d{2}| in our preamble
% for a column of figures to at most two decimal places.
%
% A rather different use of the \verb|\newcolumn| system takes
% advantage of the fact that the replacement text in the
% \verb|\newcolumn| command may refer to more than one column. Suppose
% that a document contains a lot of tabular environments that require
% the same preamble, but you wish to experiment with different
% preambles. Lamport's original definition allowed you to do the
% following (although it was probably a mis-use of the system).\\
% \verb|\newcommand{\X}{clr}|\\
% \verb|\begin{tabular}{\X}| \ldots\\
% {\tt array.sty} takes great care {\bf not} to expand the preamble, and
% so the above does not work with the new scheme. With {\tt newarray.sty}
% this functionality is returned:\\
% \verb|\newcolumn{X}{clr}|\\
% \verb|\begin{tabular}{X}| \ldots
%
% The replacement text in a \verb|\newcolumn| command may refer to any of
% the primitives of {\tt array.sty}, or to any new letters defined in other
% \verb|\newcolumn| commands. As a convenience I repeat from {\tt
% array.doc} the table of primitive options that {\tt array.sty} adds which
% differ from those described in the \LaTeX\ book.
% \begin{center}
%    \setlength{\extrarowheight}{1pt}
%    \begin{tabular}{|>{\tt}c|m{9cm}|}
%       \hline
%       m\{width\}    &  Defines a column of width {\tt width}.
%                        Every entry will be centered in proportion to
%                        the rest of the line. It is somewhat like
%                        \verb+\parbox{width}+. \\
%       \hline
%       p\{width\}    &  Equivalent to \verb+\parbox[t]{width}+. \\
%       \hline
%       b\{width\}    &  Coincides with \verb+\parbox[b]{width}+. \\
%       \hline
%       >\{decl.\}    &  Can be used before an {\tt l}, {\tt r},
%                        {\tt c}, {\tt p}, {\tt m} or a {\tt b}
%                        option. It inserts
%                        {\tt decl.} directly in front of the entry of
%                        the column.   \\
%       \hline
%       <\{decl.\}    &  Can be used after an {\tt l}, {\tt r},
%                        {\tt c}, \verb+p{..}+, \verb+t{..}+ or a
%                        \verb+b{..}+ option.
%                        It inserts {\tt decl.} right after the entry
%                        of the column.   \\
%       \hline
%       |             &  Inserts a vertical line. The distance between
%                        two columns will be enlarged by the width of
%                        the line
%                        in contrast to the original definition of
%                        \LaTeX.  \\
%       \hline
%       !\{decl.\}    &  Can be used anywhere and corresponds with the
%                        {\tt |} option. The difference is that
%                        {\tt decl.} is inserted instead of a vertical
%                        line, so this option doesn't suppress the
%                        normally inserted space between columns in
%                        contrast to \verb+@{...}+.\\
%       \hline
%    \end{tabular}
% \end{center}
%
% \subsection{Delimiters}
%
% The second addition to {\tt array.sty} added in {\tt newarray.sty} is a
% system of implicit \verb|\left| \verb|\right| pairs.
% If you want an array surrounded by parentheses, you can enter:\\
% \verb|\begin{array}({clc})| \ldots\\
% Any delimiter may appear in these positions. Thus a \PlainTeX\ user
% may recognise the following environments:\\
% \verb|\newenvironment{cases}{\begin{array}\{{lL}.}{\end{array}}|\\
% \verb|\newenvironment{matrix}{\begin{array}{*{20}{c}}}{\end{array}}|\\
% \verb|\newenvironment{pmatrix}{\begin{array}({*{20}{c}})}{\end{array}}|\\
% This feature is especially useful if the \verb|[t]| or \verb|[b]|
% arguments are also used. In these cases the result is not equivalent
% to surrounding the environment by \verb|\left|\ldots\verb|\right|, as
% can be seen from the following example:
% \[
% \begin{array}[t]({c}) 1\\2\\3 \end{array}
% \begin{array}[c]({c}) 1\\2\\3 \end{array}
% \begin{array}[b]({c}) 1\\2\\3 \end{array}
% \quad\mbox{not}\quad
% \left(\begin{array}[t]{c} 1\\2\\3 \end{array}\right)
% \left(\begin{array}[c]{c} 1\\2\\3 \end{array}\right)
% \left(\begin{array}[b]{c} 1\\2\\3 \end{array}\right)
% \]
% \begin{verbatim}
% \begin{array}[t]({c}) 1\\2\\3 \end{array}
% \begin{array}[c]({c}) 1\\2\\3 \end{array}
% \begin{array}[b]({c}) 1\\2\\3 \end{array}
% \quad\mbox{not}\quad
% \left(\begin{array}[t]{c} 1\\2\\3 \end{array}\right)
% \left(\begin{array}[c]{c} 1\\2\\3 \end{array}\right)
% \left(\begin{array}[b]{c} 1\\2\\3 \end{array}\right)
% \end{verbatim}
%
% \section{Final Comments}
%
% \subsection{Comparisons with {\tt array.sty}}
%
% It is the intention that given correct input for {\tt array.sty}, {\tt
% newarray.sty} will produce an identical {\tt dvi} file. Any such
% difference in behaviour is a bug. This file was tested with {\tt
% array.doc} fileversion (v2.0d) filedate (90/08/20) docdate (90/08/20).
%
% There are some differences in the way the two styles treat incorrect
% input, even if the source file does not appear to use any of the extra
% features of {\tt newarray.sty}.
% \begin{itemize}
% \item A preamble of the form \verb|{wx*{0}{abc}yz}| is treated by
% Mittelbach's style as \verb|{wx}|. This style treats it as
% \verb|{wxyz}|
% \item An incorrect positional argument such as {\tt [Q]} is treated as
% {\tt [c]} by {\tt array.sty}, but as {\tt [t]} by {\tt newarray.sty}.
% (This was slightly more convenient for me, but I could change this if
% necessary.)
% \item A preamble such as \verb|{cc*{2}}| with an error in a
% $*$-form will generate different errors in the two styles. In both cases
% the error message is not particularly helpful to the casual user.
% \item Repeated {\tt <} or {\tt >} constructions generate an error in
% {\tt array.sty}, but are allowed in this style.
% \verb|>{|\meta{decs1}\verb|}>{|\meta{decs2}\verb|}| is treated
% the same as \verb|>{|\meta{decs2}\meta{decs1}\verb|}|.
% \item The \verb|\extracolsep| command does not work with {\tt array.sty},
% see the comments in {\tt array.bug}. With {\tt newarray.sty}
% \verb|\extracolsep| may be used in {\tt@}-expressions as in standard
% \LaTeX, and also in {\tt!}-expressions.
% \end{itemize}
% \subsection{Bugs and Features}
%
% \begin{itemize}
% \item The documentation is in English only. (Sorry.)
% \item Error messages comming from \verb|\@preamerr| refer to the
% preamble argument {\bf after} it has been re-written by the
% \verb|\newcolumn| system, not to the preamble entered by the user.
% This seems inevitable with any system based on pre-processing and so
% is classed as a {\bf feature}.
% \item The treatment of multiple {\tt<} or {\tt>} declarations may seem
% strange at first. Earlier versions of this style treated
% \verb|>{|\meta{decs1}\verb|}>{|\meta{decs2}\verb|}|
% the same as \verb|>{|\meta{decs1}\meta{decs2}\verb|}|. However this did not
% give the user the opportunity of overriding the settings of a
% \verb|\newcolumn|  defined using these declarations. For example, suppose
% in an {\tt array} environment we use a {\tt C} column defined as above.
% The {\tt C} specifies a centred text column, however \verb|>{\bf}C|,
% which re-writes to \verb|>{\bf}>{$}c<{$}| would not specify a bold column as might
% be expected, as the preamble would essentially expand to
% \verb|\hfil$\bf$#$ $\hfil| and so the column entry would not be in the scope
% of the \verb|\bf|\,! The present version switches the order of repeated
% declarations, and so the above example now produces a preamble of the
% form \verb|\hfil$ $\bf#$ $\hfil|, and the dollars cancel each other out
% without limiting the scope of the \verb|\bf|.
% \end{itemize}
%
% \typeout{End of the Introduction and Examples.}
% \typein[\answer]%
%   {Do you want an annotated listing of the macro definitions (y/n) ?}
% \def\next{y}\ifx\answer\next\else\expandafter\stop\fi
%
% \section{The Macros}
%
% If \verb|\newcolumn| is defined, do not re-load this file.
%    \begin{macrocode}
\@ifundefined{newcolumn}{}{\endinput}
%    \end{macrocode}
% Input {\tt array.sty} if it is not already loaded.
%    \begin{macrocode}
\@ifundefined{extrarowheight}{\input array.sty}{}
%    \end{macrocode}
%
% \subsection{Defining your own column specifiers ({\protect\tt\bslash
% newcolumn})}
%
% \begin{macro}{\newcolumn}
% As described above, the \verb|\newcolumn| macro gives users the chance to
% define letters, to be used in the  same way as the primitive column
% specifiers, `c' `p' etc.
%    \begin{macrocode}
\def\newcolumn#1{%
%    \end{macrocode}
% First we check whether there is already a definition for this column.
% Unlike \verb|\newcommand| we give a warning rather than an error if it is
% defined. If it is a new column, add \verb|\NC@do| \meta{column} to
% the list \verb|NC@list|.
%    \begin{macrocode}
  \@ifundefined{NC@find@#1}%
    {\@tfor\next:=<>clrmbp@!|\do{\if\next#1
                    \@warning{Redefining primitive column #1}\fi}%
     \NC@list\expandafter{\the\NC@list\NC@do#1}}%
    {\@warning{Column #1 is already defined}}%
%    \end{macrocode}
% Now we define a macro with an argument delimited by the new column
% specifier, this is used to find occurences of this specifier in the
% user preamble.
%    \begin{macrocode}
  \@namedef{NC@find@#1}##1#1{\NC@{##1}}%
%    \end{macrocode}
% If an optional argument was not given, give a default argument of 0.
%    \begin{macrocode}
  \@ifnextchar[{\newcol@{#1}}{\newcol@{#1}[0]}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\newcol@}
% We can now define the macro which does the rewriting,
% \verb|\@reargdef| takes the same arguments as \verb|\newcommand|, but
% does not check that the command is new. For a column, say `D' with
% one argument, define a command \verb|\NC@rewrite@D| with one
% argument, which recursively calls \verb|\NC@find| on the user preamble
% after replacing the first token or group with the replacement text
% specified in the \verb|\newcolumn| command. \verb|\NC@find| will find the
% next occurrence of `D' as it will be \verb|\let| equal to
% \verb|\NC@find@D| by \verb|\NC@do|.
%    \begin{macrocode}
\def\newcol@#1[#2]#3{\expandafter\@reargdef
     \csname NC@rewrite@#1\endcsname[#2]{\NC@find#3}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\NC@}
% Having found an occurence of the new column, save the preamble
% before the column in \verb|\@temptokena|, then check to see if we
% are at the end of the preamble. (A dummy occurrence of the column
% specifier will be placed at the end of the preamble by \verb|\NC@do|.
%    \begin{macrocode}
\def\NC@#1{%
  \@temptokena\expandafter{\the\@temptokena#1}\futurelet\next\NC@ifend}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\NC@ifend}
% We can tell that we are at the end as \verb|\NC@do| will place a
% \verb|\relax| after the dummy column.
%    \begin{macrocode}
\def\NC@ifend{%
%    \end{macrocode}
% If we are at the end, do nothing. (The whole preamble will now be in
% \verb|\@temptokena|.)
%    \begin{macrocode}
  \ifx\next\relax
%    \end{macrocode}
% Otherwise set the flag \verb|\if@tempswa|, and rewrite the column.
%    \begin{macrocode}
    \else\def\next{\@tempswatrue\NC@rewrite}\fi\next}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\NC@do}
% If the user has specified `C' and `L' as new columns, the list of
% rewrites (in the token register \verb|\NC@list|) will look like
% \verb|\NC@do *| \verb|\NC@do C| \verb|\NC@do L|. So we need to
% define \verb|\NC@do| as a one argument macro which initialises the
% rewriting of the specified column. Let us assume that `C' is the argument.
%    \begin{macrocode}
\def\NC@do#1{%
%    \end{macrocode}
% First we let \verb|\NC@rewrite| be \verb|\NC@rewrite@C|.
%    \begin{macrocode}
  \expandafter\let\expandafter\NC@rewrite\csname NC@rewrite@#1\endcsname
%    \end{macrocode}
% Then we let \verb|NC@find| be \verb|NC@find@C|.
%    \begin{macrocode}
  \expandafter\let\expandafter\NC@find\csname NC@find@#1\endcsname
%    \end{macrocode}
% Finally we clear the token register \verb|\@temptokena| after
% putting the present contents of the register in front of the token
% \verb|\NC@find|. At the end we place the tokens `\verb|C\relax|'
% which \verb|\NC@ifend| will use to detect the end of the user
% preamble.
%    \begin{macrocode}
  \expandafter\@temptokena\expandafter{\expandafter}%
        \expandafter\NC@find\the\@temptokena#1\relax}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\showcols}
% This macro is useful for debugging \verb|\newcolumn| specifications,
% it is the equivalent of the primitive \verb|\show| command for macro
% definitions. All we need to do is locally redefine \verb|\NC@do| to
% take its argument (say `C') and then \verb|\show| the (slightly
% modified) definition of \verb|\NC@rewrite@C|. Actually as the the
% list always starts off with \verb|\NC@do *| and we do not want to
% print the definition of the $*$-form, define \verb|\NC@do| to throw away
% the first item in the list, and then redefine itsef to print the rest of
% the definitions.
%    \begin{macrocode}
\def\showcols{{\def\NC@do##1{\let\NC@do\NC@show}\the\NC@list}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\NC@show}
% \begin{macro}{\NC@strip}
% If the column `C' is defined as above, then
% \verb|\show\NC@rewrite@C| would output\\
% \verb|\long macro: ->\NC@find >{$}c<{$}|.
% We want to strip the \verb|long macro: ->| and
% the \verb|\NC@find|. So first we use \verb|\meaning| and then apply
% the macro \verb|\NC@strip| to the tokens so produced and then
% \verb|\typeout| the required string.
%    \begin{macrocode}
\def\NC@show#1{%
  \typeout{Column #1\expandafter\expandafter\expandafter\NC@strip
  \expandafter\meaning\csname NC@rewrite@#1\endcsname\@@}}
%    \end{macrocode}
% We delimit the arguments to \verb|\NC@strip| with `{\tt:}', `{\tt->}',
% a space, and \verb|\@@| to pull out the required parts of the output from
% \verb|\meaning|.
%    \begin{macrocode}
\def\NC@strip#1:#2->#3 #4\@@{#2 -> #4}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\NC@list}
% Allocate the token register used for the rewrite list.
%    \begin{macrocode}
\newtoks\NC@list
%    \end{macrocode}
% \end{macro}
%
% \subsection{The $*$--form}
% We view the $*$-form as a slight generalisation of the system
% described in the previous subsection. The idea is to define a $*$
% column by a command of the form:
% \begin{verbatim}
% \newcolumn{*}[2]{%
%    \count@=#1\ifnum\count@>0 \advance\count@ by -1 #2*{\count@}{#2}\fi}
% \end{verbatim}
% \begin{macro}{\NC@rewrite@*}\label{NC@rewrite@*}
% This does not work however as \verb|\newcolumn| takes great care not
% to expand anything in the preamble, and so the \verb|\if| is never
% expanded. \verb|\newcolumn| sets up various other parts of the
% rewrite correctly though so we can define:
%    \begin{macrocode}
\newcolumn{*}[2]{}
%    \end{macrocode}
% Now we must correct the definition of \verb|\NC@rewrite@*|. The
% following is probably more efficient than a direct translation of
% the idea sketched above, we do not need to put a $*$ in the preamble
% and call the rewrite recursively, we can just put \verb|#1| copies of
% \verb|#2| into \verb|\@temptokena|. (Nested $*$ forms will be expanded
% when the whole rewrite list is expanded again, see \verb|\@mkpream|)
%    \begin{macrocode}
\long\@namedef{NC@rewrite@*}#1#2{%
%    \end{macrocode}
% Store the number.
%    \begin{macrocode}
  \count@#1
%    \end{macrocode}
% Put \verb|#1| copies of \verb|#2| in the token register.
%    \begin{macrocode}
  \loop
  \ifnum\count@>\z@
  \advance\count@\m@ne
  \@temptokena\expandafter{\the\@temptokena#2}
  \repeat
%    \end{macrocode}
% \verb|\NC@do| will ensure that \verb|\NC@find| is \verb|\let| equal
% to \verb|\NC@find@*|.
%    \begin{macrocode}
  \NC@find}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Modifications to internal macros of {\tt array.sty}}
%
% \begin{macro}{\@xexpast}
% \begin{macro}{\@xexnoop}
% These macros are used to expand $*$-forms in {\tt array.sty}. \verb|\let|
% them to \verb|\relax| to save space.
%    \begin{macrocode}
\let\@xexpast\relax
\let\@xexnoop\relax
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\save@decl}
%    We do not assume that the token register is free, we add the
%    new declarations to the front of the register. This is to allow user
%    preambles of the form, \verb|>{foo}>{bar}..|. We do not encourage the
%    users to enter such expressions directly, but they may result from the
%    rewriting of \verb|\newcolumn|'s.
%    \begin{macrocode}
\def\save@decl{\toks \count@ = \expandafter\expandafter\expandafter
                  {\expandafter\@nextchar\the\toks\count@}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@mkpream}
%    The main modification to \verb|\@mkpream| is to replace the call to
%    \verb|\@xexpast| (which expanded $*$-forms) by a loop which expands
%    all \verb|\newcolumn| specifiers.
%    \begin{macrocode}
\def\@mkpream#1{\gdef\@preamble{}\@lastchclass 4 \@firstamptrue
   \let\@sharp\relax \let\@startpbox\relax \let\@endpbox\relax
%    \end{macrocode}
%    Now we remove possible  $*$-forms and user-defined column
%    specifiers in the user preamble by repeatedly executing the list
%    \verb|\NC@list| until the re-writes have no more effect. The
%    expanded preamble will then be in the token register
%    \verb|\@temptokena|. Actually we need to know at this point that
%    this is not \verb|\toks0|.
%    \begin{macrocode}
   \@temptokena{#1}\@tempswatrue
   \@whilesw\if@tempswa\fi{\@tempswafalse\the\NC@list}%
%    \end{macrocode}
%    Afterwards we initialize all registers and macros, that we need
%    for the build-up of the preamble.
%    \begin{macrocode}
   \count@\m@ne
   \let\the@toks\relax
   \prepnext@tok
%    \end{macrocode}
%    To evaluate the user preamble (without stars or newcolumns) saved in
%    \verb|\@temptokena| we use the \LaTeX--macro \verb|\@tfor|.
%    The strange appearing construction with \verb|\expandafter| is
%    based on the fact that we have to put the
%    contents of the register \verb|\@temptokena| and not the
%    register itself to this \LaTeX--macro.
%    \begin{macrocode}
   \expandafter \@tfor \expandafter \@nextchar
    \expandafter :\expandafter =\the\@temptokena \do
   {\@testpach\@nextchar
   \ifcase \@chclass \@classz \or \@classi \or \@classii
     \or \save@decl \or \or \@classv \or \@classvi
     \or \@classvii \or \@classviii
%    \end{macrocode}
%    In {\tt newarray.sty} class 9 is equivalent to class 10.
%    \begin{macrocode}
     \or \@classx
     \or \@classx \fi
   \@lastchclass\@chclass}%
   \ifcase\@lastchclass
   \@acol \or
   \or
   \@acol \or
   \@preamerr \thr@@ \or
   \@preamerr \tw@ \@addtopreamble\@sharp \or
   \or
   \else  \@preamerr \@ne \fi
   \def\the@toks{\the\toks}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@classix}
%    {\tt array.sty} does not allow repeated {\tt>} declarations for the
%    same column. This is allowed in {\tt newarray.sty} as documented in
%    the introduction. Removing the test for this case makes class 9
%    equivalent to class 10, and so this macro is redundant. It is
%    \verb|\let| to \verb|\relax| to save space.
%    \begin{macrocode}
\let\@classix\relax
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@classviii}
%    In {\tt newarray.sty} explicitly allow class 2, as repeated {\tt<}
%    expressions are accepted by this style.
%    \begin{macrocode}
\def\@classviii{\ifnum \@lastchclass >\z@\ifnum\@lastchclass=\tw@\else
      \@preamerr 4\@chclass 6 \@classvi \fi\fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@classv}
% Class 5 is {\tt@}-expressions (and is also called by class 1)
% The \verb|\toks@{\@nextchar}| has been added so that
% \verb|\extracolumnsep| works.
%  \verb|@{A\extacolumnsep{1in}B}|
% will result in an extra
% \verb|\toks@{A\tabskip 1in\relax B}|
% being added to \verb|\@preamble|. The preamble constructed by
% \verb|\halign| will have the tokens \verb|\toks@{A\relax B}| which will
% cause no output. The tokens \verb|\tabskip 1in| will be removed and used
% to set the \verb|\tabskip| glue. This means that {\tt tabular*} is usable
% with this style without the user having to type \verb|\tabskip=1in| in
% {\tt the @} expression.
%    \begin{macrocode}
\def\@classv{\save@decl
   \@addtopreamble{\d@llar
   \toks@{\@nextchar}%
   \the@toks\the\count@\relax\d@llar}%
   \prepnext@tok}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@array}
% \verb|\@array| is modified to call \verb|\@arrayleft|, which will have a
% local definition depending on the whether delimiters or positional
% arguments were specified.
%    \begin{macrocode}
\def\@array[#1]#2{%
  \@tempdima \ht \strutbox
  \advance \@tempdima by\extrarowheight
  \setbox \@arstrutbox \hbox{\vrule
             \@height \arraystretch \@tempdima
             \@depth \arraystretch \dp \strutbox
             \@width \z@}%
  \begingroup
  \@mkpream{#2}%
  \xdef\@preamble{\ialign \@halignto
                  \bgroup \@arstrut \@preamble
                          \tabskip \z@ \cr}%
  \endgroup
%    \end{macrocode}
%     The macro \verb|\@@array| will have processed the arguments of
%     the environment, and defined \verb|\@arrayleft| appropriately,
%     thus it may put a left delimiter before the box, or it may
%     initialse a box register, or it may do nothing.
%    \begin{macrocode}
  \@arrayleft
%    \end{macrocode}
% Incorect positional arguments are equivalent to \verb|[t]| in  {\tt
% newarray.sty}.
%    \begin{macrocode}
  \if #1c\vcenter \else \if#1b\vbox \else \vtop \fi \fi
  \bgroup
  \let \@sharp ##\let \protect \relax
  \lineskip \z@
  \baselineskip \z@
  \m@th
  \let\\ \@arraycr  \let\par\@empty \@preamble}
%    \end{macrocode}
% \end{macro}
%
%
%   \subsection{Optional Arguments and Delimiters}
%
% \begin{macro}{\@tabarray}
%    This macro tests for an optional bracket and then calls up
%    \verb|\@@array| or \verb|\@@array[c]| (as default).
%    \begin{macrocode}
\def\@tabarray{\@ifnextchar[{\@@array}{\@@array[c]}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@array}
%    This macro tests for an optional delimiter before the left brace
%    of the main preamble argument. If there is no delimiter,
%    \verb|\@arrayleft| and \verb|\@arrayright| are made a no-ops, and
%    \verb|\@array| is called with the positional argument. Otherwise
%    call \verb|\@del@array|.
%    \begin{macrocode}
\def\@@array[#1]{\@ifnextchar\bgroup
  {\let\@arrayleft\relax\let\@arrayright\relax\@array[#1]}%
  {\@del@array[#1]}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@del@array}
%    We now know that we have an array (or tabular) with delimiters.
%    \begin{macrocode}
\def\@del@array[#1]#2#3#4{%
%    \end{macrocode}
% The following line is completely redundant but it does catch errors
% involving delimiters  before the processing of the alignment begins.
% A common error is likely to be omiting the `.' in a
% \verb|\cases|-type construction. This causes the first token of the
% alignment to be gobbled, possibly causing lots of spurious errors
% before the cause of the error, the missing delimiter, is discovered as
% \verb|\@arrayright| puts the alignment and the delimiters together.
%    \begin{macrocode}
  \setbox\z@\hbox{$\left#2\right#4$}%
%    \end{macrocode}
% In the case of a `c' argument we do not need to rebox the alignment,
% so we can define \verb|\@arrayleft| and \verb|\@arrayright| just to
% insert the delimiters.
%    \begin{macrocode}
  \if#1c\def\@arrayleft{\left#2}\def\@arrayright{\right#4}%
%    \end{macrocode}
% Otherwise we (should) have a {\tt[t] or [b]} argument, so first we
% store the alignment, without delimiters in box0.
%    \begin{macrocode}
  \else\def\@arrayleft{\setbox\z@}
%    \end{macrocode}
% Then after the alignment is finished:
%    \begin{macrocode}
  \def\@arrayright{%
%    \end{macrocode}
% Calculate the amount the box needs to be lowered (this will be
% negative in the case of \verb|[b]|). A little bit of arithmetic cf.\
% the \TeX{}Book, Appendix G, rule 8. We calculate the amount this
% way, rather than just taking the difference between the depth of box0
% and the depth of the box defined below, as the depth of that box may
% be affected by the delimiters if \verb|\delimitershortfall| or
% \verb|\delimiterfactor| have non-standard values.
%    \begin{macrocode}
     \dimen@=\dp\z@
     \advance\dimen@-\ht\z@
     \divide \dimen@ by \tw@
     \advance\dimen@ by\fontdimen22 \textfont\tw@
%    \end{macrocode}
% Now lower the alignment and the delimiters into place.
%    \begin{macrocode}
     \lower\dimen@\hbox{$\left#2\vcenter{\unvbox\z@}\right#4$}}%
%    \end{macrocode}
% End the \verb|\if#1c|
%    \begin{macrocode}
  \fi
%    \end{macrocode}
% Now that we have defined \verb|\@arrayleft| and \verb|\@arrayright|, call
% \verb|\@array|.
%    \begin{macrocode}
  \@array[#1]{#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\endarray}
%    The macro \verb|\@arrayright| will have been defined by
%    \verb|\@@array| to do `the right thing' with any delimiters or further
%    positioning required.
%    \begin{macrocode}
\def\endarray{\crcr \egroup \egroup \@arrayright \gdef\@preamble{}}
%    \end{macrocode}
% \end{macro}
%

% \end{document}
