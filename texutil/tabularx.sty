%% Save file as: TABULARX.STY           Source: FILESERV@SHSU.BITNET  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iffalse
                  tabularx.sty
                  %%%%%%%%%%%%

 \begin{tabularx}{final width}{tabular-preamble}
   tabular body
 \end{tabularx}

 In the {tabular-preamble} argument, X should be used to denote a column
 that gets the final specification of p{<whatever width is needed>}.

 So for example
    \begin{tabularx}{250pt}{|cXcX|}
        ...
    \end{tabularx}
 is equivalent to
    \begin{tabular*}{250pt}{|cp{??}cp{??}|}
       ...
    \end{tabular*}
 where the ?? is chosen automatically.

 This style requires my newarray.sty, and Mittelbach's array.sty.

                   David Carlisle
                   carlisle@uk.ac.man.cs
                   30-JAN-92
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% If you have Mittelbach's doc.sty, this file may be formatted with a
% command like:    latex tabularx.sty
% (You do not need doc.sty to {\em use} this style.)
%
% To create a faster loading .sty file, copy this file to tabularx.doc
% Then remove all the lines beginning with a `%' from the .sty file. This
% may be done with docstrip.tex, or your text editor. The following two
% lines may also be deleted from the .sty file.
\ifcat a\noexpand @\let\next\relax\else\def\next{%
    \documentstyle[tabularx,doc]{article}\MakePercentIgnore}\fi\next
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \textwidth=365pt   ^^A Allow verbatim text with 75 columns.
% \CodelineIndex     ^^A Code lines numbered.
% \DisableCrossrefs  ^^A No Cross references.
%
% \title{tabularx.sty}
% \author{D. P. Carlisle}
% \date{30-JAN-92}
% \begin{document}
% \maketitle
% \begin{abstract}
% A new environment, {\tt tabularx}, is defined, which takes the same
% arguments as {\tt tabular*}, but modifies the widths of certain columns,
% rather than the inter column space, to set a table with the requested
% total width. The columns that may stretch are marked with the new token
% {\tt X} in the preamble argument.
%
% This style requires my {\tt newarray.sty}, and Mittelbach's {\tt
% array.sty}
% \end{abstract}
%
% \section{Introduction}
% This style file implements a version of the {\tt tabular} environment in
% which the widths of certain columns are calculated so that the table is
% is a specified width. Requests for such an environment seem to occur
% quite regularly in {\tt comp.text.tex}.
%
% The columns which are affected by the {\tt tabularx} environment should
% be denoted with the letter {\tt X} in the preamble argument. The {\tt X}
% column specification will be converted to
% \verb|p{|\meta{some value}\verb|}| once the correct column width has been
% calculated.
%
% \section{Examples}
% \tracingtabularx
% The following table is set with
% \verb+\begin{tabularx}{250pt}{|c|X|c|X|} ...+.
%
% \begin{tabularx}{250pt}{|c|X|c|X|}
% \hline
% \multicolumn{2}{|c|}{Multicolumn entry!}&
% THREE&
% FOUR\\
% \hline
% one&
% \raggedright\arraybackslash The width of this column depends on the width of the table.&
% three&
% \raggedright\arraybackslash Column four will act in the same way as column two, with the same
% width.\\
% \hline
% \end{tabularx}
%
% \smallskip\noindent
% If we change the first line to \verb+\begin{tabularx}{300pt}{|c|X|c|X|}+ we
% get:
%
% \begin{tabularx}{300pt}{|c|X|c|X|}
% \hline
% \multicolumn{2}{|c|}{Multicolumn entry!}&
% THREE&
% FOUR\\
% \hline
% one&
% \raggedright\arraybackslash The width of this column depends on the width of the table.&
% three&
% \raggedright\arraybackslash Column four will act in the same way as  column two, with the same
% width.\\
% \hline
% \end{tabularx}
%

% \section{Differences between {\tt tabularx} and {\tt tabular*}}
% These two environments take the same arguments, to produce a table of a
% specified width. The main differences between them are:
% \begin{itemize}
% \item {\tt tabularx} modifies the widths of the {\em columns\/}, whereas
% {\tt tabular*} modifies the widths of the inter-column {\em spaces\/}.
% \item {\tt tabular} and {\tt tabular*} environments may be nested with no
% restriction, however if one {\tt tabularx} environment occurs inside
% another, then the inner one {\em must\/} be enclosed by \verb|{ }|.
% \item The body of the {\tt tabularx} environment is in fact the argument
% to a command, and so certain constructions which are not allowed in
% command arguments (like \verb|\verb|) may not be used.
% \item {\tt tabular*} uses a primitive capability of \TeX\ to modify the
% inter column space of an alignment. {\tt tabularx} has to set the table
% several times as it searches for the best column widths, and is therefore
% much slower. Also the fact that the body is expanded several times may
% break certain \TeX\ constructs.
% \end{itemize}
%
% \section{Customising the behaviour of {\tt tabularx}}
%
% \subsection{Terminal output}
% \DescribeMacro{\tracingtabularx}
% If this declaration is made, say in the document preamble, then all
% following {\tt tabularx} environments will print information about column
% widths as they repeatedly re-set the tables until to find the correct widths.
%
% \subsection{The environment used to typeset the {\tt X} columns}
% By default the {\tt X} specification is turned into
% \verb|p{|\meta{some value}\verb|}|. Such narrow columns often
% require a special format, this may be achieved using the \verb|>| synatax
% of {\tt array.sty}. So for example you may give a specification of
% \verb|>{\small}X|. Another format which is useful in narrow columns is
% ragged right, however \LaTeX's \verb|\raggedright| macro redefines
% \verb|\\| in a way which conflicts with its use in a tabular or array
% environments.
%\DescribeMacro{\arraybackslash}
% For this reason this style introduces the command \verb|\arraybackslash|,
% this may be used after a \verb|\raggedright|, \verb|\raggedleft|  or
% \verb|\centering| declaration. Thus a {\tt tabularx} preamble may specify\\
% \verb|>{\raggedright\arraybackslash}X|.
%
% \DescribeMacro{\newcolumn}
% These preamble specifications may of course be saved using the
% \verb|\newcolumn| command defined in {\tt newarraysty}. Thus we may
% say\\
% \verb|\newcolumn{Y}{>{\small\raggedright\arraybackslash}X}|\\
% and then use {\tt Y} in the {\tt tabularx} preamble argument.
%
% \DescribeMacro{\tabularxcolumn}
% The {\tt X} columns are set using the {\tt p} column which corresponds to
% \verb|\parbox[t]|. You may want them set using, say, the {\tt m} column,
% which corresponds to \verb|\parbox[c]|. It is not possible to change the
% column type using the \verb|>| syntax, so another system is provided.
% \verb|\tabularxcolumn| should be defined to be a macro with one argument,
% which expands to the {\tt tabular} preamble specification that you want
% to correspond to {\tt X}. The argument will be replaced by the calculated
% width of a column.

% The default is \verb|\newcommand{\tabularxcolumn}[1]{p{#1}}|. So we may
% change this with a command such as:\\
% \hbox{\verb|\renewcommand{\tabularxcolumn}[1]{>{\raggedright\arraybackslash}m{#1}}|\hskip-1in}
%
% \subsection{Column widths}
% Normally all {\tt X} columns in a single table are set to the same width,
% however it is possible to make {\tt tabularx} set them to different
% widths.
% A preamble argument of \verb|{>{\hsize=.5\hsize}X>{\hsize=1.5\hsize}X}|
% specifies two columns, the second will be three times as wide as the
% first. However if you want to play games like this you should follow the
% following two rules.
% \begin{itemize}
% \item Make sure that the sum of the widths of all the {\tt X} columns is
% unchanged. (In the above example, the new widths still add up to twice
% the default width, the same as two standard {\tt X} columns.)
% \item Do not use \verb|\multicolumn| entries which cross any {\tt X} column.
% \end{itemize}
% As with most rules, these may be broken if you know what you are doing.
%
% \typeout{End of the Introduction and Examples.}
% \typein[\answer]%
%   {Do you want an annotated listing of the macro definitions (y/n) ?}
% \def\next{y}\ifx\answer\next\else\expandafter\stop\fi
%
% \section{The Macros}
%

% This requires {\tt newarray.sty}, so we may as well load it if
% \verb|\newcolumn| is not defined.
%    \begin{macrocode}
\@ifundefined{newcolumn}{\input newarray.sty}{}
%    \end{macrocode}

%
% First some registers etc.\ that we need.
%    \begin{macrocode}
\newdimen\TX@col@width
\newdimen\TX@old@table
\newdimen\TX@old@col
\newdimen\TX@target
\newdimen\TX@delta
\newcount\TX@cols
\newif\ifTX@
%    \end{macrocode}

%
% Now a trick to get the body of an environment into a token register,
% without doing any expansion. This does not do any real checking of nested
% environments, so if you should need to nest one {\tt tabularx} inside
% another, the inner one must be surrounded by \verb|{ }|.
%
% \begin{macro}{\tabularx}
% Save the first two arguments in registers, and  clear the
% token register \verb|\toks@|. Then call \verb|\TX@get@body| to begin
% saving the body of the table.
%    \begin{macrocode}
\def\tabularx#1#2{%
  \TX@target=#1
  \TX@typeout{Target width: #1 = \the\TX@target.}%
  \@temptokena={#2}\toks@={}\TX@get@body}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TX@get@body}
% Place all tokens as far as the first \verb|\end| into a token register.
% Then call \verb|\TX@find@end| to see if we are at \verb|\end{tabularx}|.
%    \begin{macrocode}
\long\def\TX@get@body#1\end{\toks@=\expandafter{\the\toks@#1}\TX@find@end}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TX@find@end}
% If we are at \verb|\end{tabularx}|, call \verb|\TX@endtabularx|, otherwise
% add \verb|\end{...}| to the register, and call \verb|\TX@get@body| again.
%    \begin{macrocode}
\def\TX@find@end#1{%
  \def\@tempa{#1}%
  \ifx\@tempa\TX@\expandafter\TX@endtabularx
  \else\toks@=\expandafter{\the\toks@\end{#1}}\expandafter\TX@get@body\fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TX@}
% The string {\tt tabularx} as a macro for testing with \verb|\ifx|.
%    \begin{macrocode}
\def\TX@{tabularx}
%    \end{macrocode}
% \end{macro}
%
% Now that all the parts of the table specification are stored in
% registers, we can begin the work of setting the table.
%
% The algorithm for finding the correct column widths is as follows.
% Firstly set the table with each {\tt X} column the width of the final
% table. Assuming that there is at least one {\tt X} column, this will
% produce a table that is too wide. Divide the excess width by the number
% of {\tt X} columns, and reduce the column width by this amount. Reset
% the table. If the table is not now the correct width, a
% \verb|\multicolumn| entry must be `hiding' one of the {\tt X} columns,
% and so there is one less {\tt X} column affecting the width of the table.
% So we reduce by 1 the number of X columns and repeat the process.
%
% \begin{macro}{\TX@endtabularx}
% Although I have tried to make {\tt tabularx} look like an environment, it
% is in fact a command, all the work is done by this macro.
%    \begin{macrocode}
\def\TX@endtabularx{%
%    \end{macrocode}
% Define the {\tt X} column, with an internal version of the \verb|\newcolumn|
% command. The \verb|\expandafter| commands enable \verb|\NC@newcol| to get
% the {\em expansion} of\\
% \verb|\tabularxcolumn{\TX@col@width}| as its
% argument. This will be the definition of an {\tt X} column, as discussed
% in section 4.
%    \begin{macrocode}
  \expandafter\TX@newcol\expandafter{\tabularxcolumn{\TX@col@width}}%
%    \end{macrocode}
% Initialise the column width, and the number of {\tt X} columns. The
% number of {\tt X} columns is set to one, which means that the initial
% count will be one too high, but this value is decremented before it is
% used in the main loop.
%    \begin{macrocode}
  \TX@old@table=\maxdimen
  \TX@col@width=\TX@target
  \global\TX@cols=\@ne
%    \end{macrocode}
% Typeout some headings (unless this is disabled).
%    \begin{macrocode}
  \TX@typeout{\@spaces Table Width\@spaces Column Width\@spaces X Columns}%
%    \end{macrocode}%
% First attempt. Modify the {\tt X} definition to count {\tt X} columns.
%    \begin{macrocode}
  \TX@trial{\def\NC@rewrite@X{%
          \global\advance\TX@cols\@ne\NC@find p{\TX@col@width}}}%
%    \end{macrocode}
% Repeatedly decrease column width until table is the correct width,
% or stops shrinking, or the columns become two narrow.
% If there are no multicolumn entries, this will only take one attempt.
%    \begin{macrocode}
  \loop
    \TX@arith
    \ifTX@
    \TX@trial{}%
  \repeat
%    \end{macrocode}
% One last time, with warnings back on (see appendix D)
% use {\tt tabular*} to put it in a box of the right size, in case the
% algorithm failed to find the correct size.
%    \begin{macrocode}
    \csname tabular*\expandafter\endcsname\expandafter\TX@target
       \expandafter{\the\@temptokena}%
      \the\toks@
    \csname endtabular*\endcsname
%    \end{macrocode}
% Now finish off the {\tt tabularx} environment. Note that we need
% \verb|\end{tabularx}| here as the \verb|\end{tabularx}| in the user's
% file is never expanded.
%    \begin{macrocode}
  \end{tabularx}}
%    \end{macrocode}
% \end{macro}
%


%
% \begin{macro}{\TX@arith}
% Calculate the column width for the next try, setting the flag
% \verb|\ifTX@| to false if the loop should be aborted.
%    \begin{macrocode}
\def\TX@arith{%
  \TX@false
  \ifdim\TX@old@table=\wd\@tempboxa
%    \end{macrocode}
% If we have reduced the column width, but the table width has not changed,
% we stop the loop, and output the table (which will cause an over-full
% alignment) with the previous value of \verb|\TX@col@width|.
%    \begin{macrocode}
    \TX@col@width=\TX@old@col
    \TX@typeout{Reached minimum width, backing up.}%
  \else
%    \end{macrocode}
% Otherwise calculate the amount by which the current table is too wide.
%    \begin{macrocode}
    \dimen@=\wd\@tempboxa
    \advance\dimen@ -\TX@target
    \ifdim\dimen@<\TX@delta
%    \end{macrocode}
% If this amount is less than \verb|\TX@delta|, stop. (\verb|\TX@delta|
% should be non-zero otherwise we may miss the target due to rounding
% error.)
%    \begin{macrocode}
      \TX@typeout{Reached target.}%
    \else
%    \end{macrocode}
% Reduce the number of effective {\tt X} columns by one. (Checking that we
% do not get 0, as this would produce an error later.) Then divide excess
% width by the number of effective columns, and calculate the new column
% width. Temporarily store this value (times -1) in \verb|\dimen@|.
%    \begin{macrocode}
      \ifnum\TX@cols>\@ne
        \advance\TX@cols by \m@ne
      \fi
      \divide\dimen@ by \TX@cols
      \advance\dimen@ by -\TX@col@width
      \ifdim \dimen@ > \z@
%    \end{macrocode}
% If the new width would be too narrow, abort the loop. At the moment too
% narrow, means less than 0\,pt!
%    \begin{macrocode}
        \TX@typeout{Columns too narrow.}%
      \else
%    \end{macrocode}
% Otherwise save the old settings, and set the new column width. Set the
% flag to true so that the table will be set, and the loop will be executed
% again.
%    \begin{macrocode}
        \TX@old@col=\TX@col@width
        \TX@old@table=\wd\@tempboxa
        \TX@col@width=-\dimen@
        \TX@true
      \fi
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TX@delta}
% Accept a table that is within \verb|\hfuzz| of the correct width.
%    \begin{macrocode}
\TX@delta=\hfuzz
%    \end{macrocode}
% \end{macro}
%
% Initialse the {\tt X} column. The definition can be empty here, as it is
% set for each {\tt tabularx} environment.
%    \begin{macrocode}
\newcolumn{X}{}
%    \end{macrocode}
%
% \begin{macro}{\tabularxcolumn}
% The default definition of {\tt X} is \verb|p{#1}|.
%    \begin{macrocode}
\def\tabularxcolumn#1{p{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TX@newcol}
% A little macro just used to cut down the number of \verb|\expandafter|
% commands needed.
%    \begin{macrocode}
\def\TX@newcol{\newcol@{X}[0]}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TX@trial}
% Make a test run.
%    \begin{macrocode}
\def\TX@trial#1{%
  \setbox\@tempboxa=\hbox{%
%    \end{macrocode}
% Any extra commands. This is used on the first run to count the number of
% {\tt X} columns.
%    \begin{macrocode}
    #1\relax
%    \end{macrocode}
% Do not nest {\tt tabularx} environments during trial runs. This would waste
% time, and the global setting of \verb|\TX@cols| would break the algorithm.
%    \begin{macrocode}
    \expandafter\let\expandafter\tabularx\csname tabular*\endcsname
    \expandafter\let\expandafter\endtabularx\csname endtabular*\endcsname
%    \end{macrocode}
% Turn off warnings (see appendix D). Also prevent them being turned back
% on by setting the parameter names to be registers.
%    \begin{macrocode}
    \hbadness=\@M\hfuzz=\maxdimen
    \let\hbadness=\@tempcnta\let\hfuzz=\@tempdima
%    \end{macrocode}
% Make the table, and finish the hbox.
%    \begin{macrocode}
    \expandafter\tabular\expandafter{\the\@temptokena}%
      \the\toks@
    \endtabular}%
%    \end{macrocode}
% Print some statistics.
%    \begin{macrocode}
  \TX@typeout{%
  \@spaces\the\wd\@tempboxa\@spaces\the\TX@col@width\@spaces\the\TX@cols}}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\arraybackslash}
% \verb|\\| hack.
%    \begin{macrocode}
\def\arraybackslash{\let\\=\@arraycr}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tracingtabularx}
% Print statistics on column and table widths.
%    \begin{macrocode}
\def\tracingtabularx{\let\TX@typeout\typeout}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\TX@typeout}
% The default is to be to be quiet
%    \begin{macrocode}
\let\TX@typeout\@gobble
%    \end{macrocode}
% \end{macro}

% The end.
%    \begin{macrocode}
\endinput
%    \end{macrocode}


% \end{document}

