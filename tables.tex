%
% $Id$
% 
%       This source code is part of
% 
%        G   R   O   M   A   C   S
% 
% GROningen MAchine for Chemical Simulations
% 
%               VERSION 2.0
% 
% Copyright (c) 1991-1999
% BIOSON Research Institute, Dept. of Biophysical Chemistry
% University of Groningen, The Netherlands
% 
% Please refer to:
% GROMACS: A message-passing parallel molecular dynamics implementation
% H.J.C. Berendsen, D. van der Spoel and R. van Drunen
% Comp. Phys. Comm. 91, 43-56 (1995)
% 
% Also check out our WWW page:
% http://md.chem.rug.nl/~gmx
% or e-mail to:
% gromacs@chem.rug.nl
% 
% And Hey:
% Giving Russians Opium May Alter Current Situation
%

\section{\swapindex{Tabulated}{function}s}
In some of the inner loops of {\gromacs} lookup tables are used 
for computation of potential and forces. 
The tables are interpolated using a cubic
spline algorithm. 
There are separate tables for electrostatic, dispersion and repulsion
interactions,
but for the sake of caching performance these have been combined
into a single array. 
The cubic spline interpolation looks like this:
\beq
y(x)~=~\eta y_i + \epsilon y_{i+1} + \frac{h^2}{6}\left[(\eta^3-\eta)y_i^{''} + (\epsilon^3-\epsilon)y_{i+1}^{''}\right]
\label{eqn:spline}
\eeq
where $\epsilon$ = 1-$\eta$, and $y_i$ and $y_i^{''}$ 
are the tabulated values of a function $y(x)$ 
and its second derivative respectively. Furthermore,
\bea
h	&=&	x_{i+1} - x_i	\\
\epsilon&=&	(x - x_i)/h
\eea
so that $0 \le\epsilon < 1$. \eqnref{spline} can be rewritten as
\beq
y(x)~=~ y_i + \epsilon\left(y_{i+1}-y_i-\frac{h^2}{6}\left(2 y_i^{''}+y_{i+1}^{''}\right)\right) + \epsilon^2\left(\frac{h^2}{2}y_i^{''}\right) + \epsilon^3\frac{h^2}{6}\left(y_{i+1}^{''}-y_i^{''}\right)
\eeq
Note that the x-dependence is completely in $\epsilon$. This can abbreviated
to
\beq
y(x)~=~ y_i + \epsilon F_i + \epsilon^2 G_i + \epsilon^3 H_i
\eeq
From this we can calculate the derivative in order to determine the forces:
\beq
\frac{{\rm d}y(x)}{{\rm d}x}~=~\frac{{\rm d}y(x)}{{\rm d}\epsilon}\frac{{\rm d}\epsilon}{{\rm d}x}~=~(F_i + 2\epsilon G_i + 3\epsilon^2 H_i)/h
\eeq
If we store in the table $y_i$, $F_i$, $G_i$ and $H_i$ we need 
a table of length 4n. The number of points per nanometer should be on the
order of 500 to 1000, for accurate representation (relative 
error $<$ 10$^{-4}$ when n = 500 points/nm). The force routines get a 
scaling factor $s$ as a parameter that is equal to the number of points per
nm. (Note that $h$ is $s^{-1}$).

The algorithm goes a little something like this:
\begin{enumerate}
\item	Calculate distance vector (\ve{r}$_{ij}$) and distance r$_{ij}$
\item	Multiply r$_{ij}$ by $s$ and truncate to an integer value $n_0$
	to get a table index
\item	Calculate fractional component ($\epsilon$ = $s$r$_{ij} - n_0$) 
	and $\epsilon^2$ 
\item	Do the interpolation to calculate the potential $V$ and the the scalar force $f$
\item	Calculate the vector force \ve{F} by multiplying $f$ with \ve{r}$_{ij}$
\end{enumerate}

The tables are stored as y$_i$, F$_i$, G$_i$, H$_i$ in the order
coulomb, dispersion, repulsion.
In total there are 12 values in each table entry.
Note that table lookup is significantly {\em slower} than computation
of the most simple Lennard-Jones and Coulomb interaction. However, it
is much faster than the shifted coulomb function used in
conjunction with the PPPM method. Finally it is much easier to modify
a table for the potential (and get a graphical representation of it)
than to modify the inner loops of the MD program.

\subsection{Your own potential function}
You can also use your own \swapindex{potential}{function}s 
without editing the {\gromacs} code. 
The potential function should be according to the following equation
\beq
V(r_{ij}) ~=~ \frac{q_i q_j}{4 \pi\epsilon_0} f(r_{ij}) + C_6 g(r_{ij}) + C_{12} h(r_{ij})
\eeq
with f,g,h user defined functions. Note that if g(r) represents 
a normal dispersion interaction, g(r) should be $<$ 0. C$_6$, C$_{12}$ and the 
charges are read from the topology. Also note that combination rules are
only supported for Lennard Jones and Buckingham, and that your tables should
match the parameters in the binary topology.

When you add the following lines in your {\tt .mdp} file:
\begin{verbatim}
rlist           = 1.0
coulombtype	= User
rcoulomb        = 1.0
vdwtype         = User
rvdw            = 1.0
\end{verbatim}
the MD program will read a single file (name can be changed with option
{\tt -table}) with seven columns of table 
lookup data in the order: x, f(x), f''(x), g(x), g''(x), h(x), h''(x).
The x should run from 0 to r$_c$+0.5, with a spacing of 0.002 nm when
you run in single precision, or 0.0005 when you run in double
precision.  This and other functions contain a singularity at x = 0, but
since atoms are normally not closer to each other than 0.1 nm, the
function value at x = 0 is not important and the tables can be started at
e.g. 0.02 nm.  In this context r$_c$ denotes
the cut-off denoted by the variables {\tt rvdw} and {\tt
rcoulomb} (see above). These variables should be the same (but need not
be 1.0) and consistent with the table data.  Finally, it is also possible
to combine a standard Coulomb with a modified LJ potential. One then specifies
e.g. coulombtype = Cut-off or coulombtype = PME, combined with vdwtype = User.
The table file must always contain the 7 columns however.


This mechanism allows the user to use their own preferred programming language,
